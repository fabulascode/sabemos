// Code generated by Prisma (prisma@1.30.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  affiliation: (where?: AffiliationWhereInput) => Promise<boolean>;
  affiliationRole: (where?: AffiliationRoleWhereInput) => Promise<boolean>;
  contactMetadata: (where?: ContactMetadataWhereInput) => Promise<boolean>;
  emailAddress: (where?: EmailAddressWhereInput) => Promise<boolean>;
  externalLink: (where?: ExternalLinkWhereInput) => Promise<boolean>;
  facilityMetadata: (where?: FacilityMetadataWhereInput) => Promise<boolean>;
  geometry: (where?: GeometryWhereInput) => Promise<boolean>;
  governmentActor: (where?: GovernmentActorWhereInput) => Promise<boolean>;
  governmentActorProfile: (
    where?: GovernmentActorProfileWhereInput
  ) => Promise<boolean>;
  governmentBody: (where?: GovernmentBodyWhereInput) => Promise<boolean>;
  governmentBodyMetadata: (
    where?: GovernmentBodyMetadataWhereInput
  ) => Promise<boolean>;
  governmentFacility: (
    where?: GovernmentFacilityWhereInput
  ) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  locationMetadata: (where?: LocationMetadataWhereInput) => Promise<boolean>;
  phoneNumber: (where?: PhoneNumberWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userProfile: (where?: UserProfileWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  affiliation: (where: AffiliationWhereUniqueInput) => AffiliationPromise;
  affiliations: (
    args?: {
      where?: AffiliationWhereInput;
      orderBy?: AffiliationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Affiliation>;
  affiliationsConnection: (
    args?: {
      where?: AffiliationWhereInput;
      orderBy?: AffiliationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AffiliationConnectionPromise;
  affiliationRole: (
    where: AffiliationRoleWhereUniqueInput
  ) => AffiliationRolePromise;
  affiliationRoles: (
    args?: {
      where?: AffiliationRoleWhereInput;
      orderBy?: AffiliationRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AffiliationRole>;
  affiliationRolesConnection: (
    args?: {
      where?: AffiliationRoleWhereInput;
      orderBy?: AffiliationRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AffiliationRoleConnectionPromise;
  contactMetadata: (
    where: ContactMetadataWhereUniqueInput
  ) => ContactMetadataPromise;
  contactMetadatas: (
    args?: {
      where?: ContactMetadataWhereInput;
      orderBy?: ContactMetadataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ContactMetadata>;
  contactMetadatasConnection: (
    args?: {
      where?: ContactMetadataWhereInput;
      orderBy?: ContactMetadataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ContactMetadataConnectionPromise;
  emailAddress: (where: EmailAddressWhereUniqueInput) => EmailAddressPromise;
  emailAddresses: (
    args?: {
      where?: EmailAddressWhereInput;
      orderBy?: EmailAddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<EmailAddress>;
  emailAddressesConnection: (
    args?: {
      where?: EmailAddressWhereInput;
      orderBy?: EmailAddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EmailAddressConnectionPromise;
  externalLink: (where: ExternalLinkWhereUniqueInput) => ExternalLinkPromise;
  externalLinks: (
    args?: {
      where?: ExternalLinkWhereInput;
      orderBy?: ExternalLinkOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExternalLink>;
  externalLinksConnection: (
    args?: {
      where?: ExternalLinkWhereInput;
      orderBy?: ExternalLinkOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExternalLinkConnectionPromise;
  facilityMetadata: (
    where: FacilityMetadataWhereUniqueInput
  ) => FacilityMetadataPromise;
  facilityMetadatas: (
    args?: {
      where?: FacilityMetadataWhereInput;
      orderBy?: FacilityMetadataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<FacilityMetadata>;
  facilityMetadatasConnection: (
    args?: {
      where?: FacilityMetadataWhereInput;
      orderBy?: FacilityMetadataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FacilityMetadataConnectionPromise;
  geometry: (where: GeometryWhereUniqueInput) => GeometryPromise;
  geometries: (
    args?: {
      where?: GeometryWhereInput;
      orderBy?: GeometryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Geometry>;
  geometriesConnection: (
    args?: {
      where?: GeometryWhereInput;
      orderBy?: GeometryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GeometryConnectionPromise;
  governmentActor: (
    where: GovernmentActorWhereUniqueInput
  ) => GovernmentActorPromise;
  governmentActors: (
    args?: {
      where?: GovernmentActorWhereInput;
      orderBy?: GovernmentActorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GovernmentActor>;
  governmentActorsConnection: (
    args?: {
      where?: GovernmentActorWhereInput;
      orderBy?: GovernmentActorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GovernmentActorConnectionPromise;
  governmentActorProfile: (
    where: GovernmentActorProfileWhereUniqueInput
  ) => GovernmentActorProfilePromise;
  governmentActorProfiles: (
    args?: {
      where?: GovernmentActorProfileWhereInput;
      orderBy?: GovernmentActorProfileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GovernmentActorProfile>;
  governmentActorProfilesConnection: (
    args?: {
      where?: GovernmentActorProfileWhereInput;
      orderBy?: GovernmentActorProfileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GovernmentActorProfileConnectionPromise;
  governmentBody: (
    where: GovernmentBodyWhereUniqueInput
  ) => GovernmentBodyPromise;
  governmentBodies: (
    args?: {
      where?: GovernmentBodyWhereInput;
      orderBy?: GovernmentBodyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GovernmentBody>;
  governmentBodiesConnection: (
    args?: {
      where?: GovernmentBodyWhereInput;
      orderBy?: GovernmentBodyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GovernmentBodyConnectionPromise;
  governmentBodyMetadata: (
    where: GovernmentBodyMetadataWhereUniqueInput
  ) => GovernmentBodyMetadataPromise;
  governmentBodyMetadatas: (
    args?: {
      where?: GovernmentBodyMetadataWhereInput;
      orderBy?: GovernmentBodyMetadataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GovernmentBodyMetadata>;
  governmentBodyMetadatasConnection: (
    args?: {
      where?: GovernmentBodyMetadataWhereInput;
      orderBy?: GovernmentBodyMetadataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GovernmentBodyMetadataConnectionPromise;
  governmentFacility: (
    where: GovernmentFacilityWhereUniqueInput
  ) => GovernmentFacilityPromise;
  governmentFacilities: (
    args?: {
      where?: GovernmentFacilityWhereInput;
      orderBy?: GovernmentFacilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GovernmentFacility>;
  governmentFacilitiesConnection: (
    args?: {
      where?: GovernmentFacilityWhereInput;
      orderBy?: GovernmentFacilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GovernmentFacilityConnectionPromise;
  location: (where: LocationWhereUniqueInput) => LocationPromise;
  locations: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Location>;
  locationsConnection: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LocationConnectionPromise;
  locationMetadata: (
    where: LocationMetadataWhereUniqueInput
  ) => LocationMetadataPromise;
  locationMetadatas: (
    args?: {
      where?: LocationMetadataWhereInput;
      orderBy?: LocationMetadataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<LocationMetadata>;
  locationMetadatasConnection: (
    args?: {
      where?: LocationMetadataWhereInput;
      orderBy?: LocationMetadataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LocationMetadataConnectionPromise;
  phoneNumber: (where: PhoneNumberWhereUniqueInput) => PhoneNumberPromise;
  phoneNumbers: (
    args?: {
      where?: PhoneNumberWhereInput;
      orderBy?: PhoneNumberOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PhoneNumber>;
  phoneNumbersConnection: (
    args?: {
      where?: PhoneNumberWhereInput;
      orderBy?: PhoneNumberOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PhoneNumberConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  userProfile: (where: UserProfileWhereUniqueInput) => UserProfilePromise;
  userProfiles: (
    args?: {
      where?: UserProfileWhereInput;
      orderBy?: UserProfileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserProfile>;
  userProfilesConnection: (
    args?: {
      where?: UserProfileWhereInput;
      orderBy?: UserProfileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserProfileConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAffiliation: (data: AffiliationCreateInput) => AffiliationPromise;
  updateAffiliation: (
    args: { data: AffiliationUpdateInput; where: AffiliationWhereUniqueInput }
  ) => AffiliationPromise;
  updateManyAffiliations: (
    args: {
      data: AffiliationUpdateManyMutationInput;
      where?: AffiliationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAffiliation: (
    args: {
      where: AffiliationWhereUniqueInput;
      create: AffiliationCreateInput;
      update: AffiliationUpdateInput;
    }
  ) => AffiliationPromise;
  deleteAffiliation: (where: AffiliationWhereUniqueInput) => AffiliationPromise;
  deleteManyAffiliations: (
    where?: AffiliationWhereInput
  ) => BatchPayloadPromise;
  createAffiliationRole: (
    data: AffiliationRoleCreateInput
  ) => AffiliationRolePromise;
  updateAffiliationRole: (
    args: {
      data: AffiliationRoleUpdateInput;
      where: AffiliationRoleWhereUniqueInput;
    }
  ) => AffiliationRolePromise;
  updateManyAffiliationRoles: (
    args: {
      data: AffiliationRoleUpdateManyMutationInput;
      where?: AffiliationRoleWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAffiliationRole: (
    args: {
      where: AffiliationRoleWhereUniqueInput;
      create: AffiliationRoleCreateInput;
      update: AffiliationRoleUpdateInput;
    }
  ) => AffiliationRolePromise;
  deleteAffiliationRole: (
    where: AffiliationRoleWhereUniqueInput
  ) => AffiliationRolePromise;
  deleteManyAffiliationRoles: (
    where?: AffiliationRoleWhereInput
  ) => BatchPayloadPromise;
  createContactMetadata: (
    data: ContactMetadataCreateInput
  ) => ContactMetadataPromise;
  updateContactMetadata: (
    args: {
      data: ContactMetadataUpdateInput;
      where: ContactMetadataWhereUniqueInput;
    }
  ) => ContactMetadataPromise;
  updateManyContactMetadatas: (
    args: {
      data: ContactMetadataUpdateManyMutationInput;
      where?: ContactMetadataWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertContactMetadata: (
    args: {
      where: ContactMetadataWhereUniqueInput;
      create: ContactMetadataCreateInput;
      update: ContactMetadataUpdateInput;
    }
  ) => ContactMetadataPromise;
  deleteContactMetadata: (
    where: ContactMetadataWhereUniqueInput
  ) => ContactMetadataPromise;
  deleteManyContactMetadatas: (
    where?: ContactMetadataWhereInput
  ) => BatchPayloadPromise;
  createEmailAddress: (data: EmailAddressCreateInput) => EmailAddressPromise;
  updateEmailAddress: (
    args: { data: EmailAddressUpdateInput; where: EmailAddressWhereUniqueInput }
  ) => EmailAddressPromise;
  updateManyEmailAddresses: (
    args: {
      data: EmailAddressUpdateManyMutationInput;
      where?: EmailAddressWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertEmailAddress: (
    args: {
      where: EmailAddressWhereUniqueInput;
      create: EmailAddressCreateInput;
      update: EmailAddressUpdateInput;
    }
  ) => EmailAddressPromise;
  deleteEmailAddress: (
    where: EmailAddressWhereUniqueInput
  ) => EmailAddressPromise;
  deleteManyEmailAddresses: (
    where?: EmailAddressWhereInput
  ) => BatchPayloadPromise;
  createExternalLink: (data: ExternalLinkCreateInput) => ExternalLinkPromise;
  updateExternalLink: (
    args: { data: ExternalLinkUpdateInput; where: ExternalLinkWhereUniqueInput }
  ) => ExternalLinkPromise;
  updateManyExternalLinks: (
    args: {
      data: ExternalLinkUpdateManyMutationInput;
      where?: ExternalLinkWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExternalLink: (
    args: {
      where: ExternalLinkWhereUniqueInput;
      create: ExternalLinkCreateInput;
      update: ExternalLinkUpdateInput;
    }
  ) => ExternalLinkPromise;
  deleteExternalLink: (
    where: ExternalLinkWhereUniqueInput
  ) => ExternalLinkPromise;
  deleteManyExternalLinks: (
    where?: ExternalLinkWhereInput
  ) => BatchPayloadPromise;
  createFacilityMetadata: (
    data: FacilityMetadataCreateInput
  ) => FacilityMetadataPromise;
  updateFacilityMetadata: (
    args: {
      data: FacilityMetadataUpdateInput;
      where: FacilityMetadataWhereUniqueInput;
    }
  ) => FacilityMetadataPromise;
  updateManyFacilityMetadatas: (
    args: {
      data: FacilityMetadataUpdateManyMutationInput;
      where?: FacilityMetadataWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertFacilityMetadata: (
    args: {
      where: FacilityMetadataWhereUniqueInput;
      create: FacilityMetadataCreateInput;
      update: FacilityMetadataUpdateInput;
    }
  ) => FacilityMetadataPromise;
  deleteFacilityMetadata: (
    where: FacilityMetadataWhereUniqueInput
  ) => FacilityMetadataPromise;
  deleteManyFacilityMetadatas: (
    where?: FacilityMetadataWhereInput
  ) => BatchPayloadPromise;
  createGeometry: (data: GeometryCreateInput) => GeometryPromise;
  updateGeometry: (
    args: { data: GeometryUpdateInput; where: GeometryWhereUniqueInput }
  ) => GeometryPromise;
  updateManyGeometries: (
    args: { data: GeometryUpdateManyMutationInput; where?: GeometryWhereInput }
  ) => BatchPayloadPromise;
  upsertGeometry: (
    args: {
      where: GeometryWhereUniqueInput;
      create: GeometryCreateInput;
      update: GeometryUpdateInput;
    }
  ) => GeometryPromise;
  deleteGeometry: (where: GeometryWhereUniqueInput) => GeometryPromise;
  deleteManyGeometries: (where?: GeometryWhereInput) => BatchPayloadPromise;
  createGovernmentActor: (
    data: GovernmentActorCreateInput
  ) => GovernmentActorPromise;
  updateGovernmentActor: (
    args: {
      data: GovernmentActorUpdateInput;
      where: GovernmentActorWhereUniqueInput;
    }
  ) => GovernmentActorPromise;
  upsertGovernmentActor: (
    args: {
      where: GovernmentActorWhereUniqueInput;
      create: GovernmentActorCreateInput;
      update: GovernmentActorUpdateInput;
    }
  ) => GovernmentActorPromise;
  deleteGovernmentActor: (
    where: GovernmentActorWhereUniqueInput
  ) => GovernmentActorPromise;
  deleteManyGovernmentActors: (
    where?: GovernmentActorWhereInput
  ) => BatchPayloadPromise;
  createGovernmentActorProfile: (
    data: GovernmentActorProfileCreateInput
  ) => GovernmentActorProfilePromise;
  updateGovernmentActorProfile: (
    args: {
      data: GovernmentActorProfileUpdateInput;
      where: GovernmentActorProfileWhereUniqueInput;
    }
  ) => GovernmentActorProfilePromise;
  updateManyGovernmentActorProfiles: (
    args: {
      data: GovernmentActorProfileUpdateManyMutationInput;
      where?: GovernmentActorProfileWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGovernmentActorProfile: (
    args: {
      where: GovernmentActorProfileWhereUniqueInput;
      create: GovernmentActorProfileCreateInput;
      update: GovernmentActorProfileUpdateInput;
    }
  ) => GovernmentActorProfilePromise;
  deleteGovernmentActorProfile: (
    where: GovernmentActorProfileWhereUniqueInput
  ) => GovernmentActorProfilePromise;
  deleteManyGovernmentActorProfiles: (
    where?: GovernmentActorProfileWhereInput
  ) => BatchPayloadPromise;
  createGovernmentBody: (
    data: GovernmentBodyCreateInput
  ) => GovernmentBodyPromise;
  updateGovernmentBody: (
    args: {
      data: GovernmentBodyUpdateInput;
      where: GovernmentBodyWhereUniqueInput;
    }
  ) => GovernmentBodyPromise;
  upsertGovernmentBody: (
    args: {
      where: GovernmentBodyWhereUniqueInput;
      create: GovernmentBodyCreateInput;
      update: GovernmentBodyUpdateInput;
    }
  ) => GovernmentBodyPromise;
  deleteGovernmentBody: (
    where: GovernmentBodyWhereUniqueInput
  ) => GovernmentBodyPromise;
  deleteManyGovernmentBodies: (
    where?: GovernmentBodyWhereInput
  ) => BatchPayloadPromise;
  createGovernmentBodyMetadata: (
    data: GovernmentBodyMetadataCreateInput
  ) => GovernmentBodyMetadataPromise;
  updateGovernmentBodyMetadata: (
    args: {
      data: GovernmentBodyMetadataUpdateInput;
      where: GovernmentBodyMetadataWhereUniqueInput;
    }
  ) => GovernmentBodyMetadataPromise;
  updateManyGovernmentBodyMetadatas: (
    args: {
      data: GovernmentBodyMetadataUpdateManyMutationInput;
      where?: GovernmentBodyMetadataWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGovernmentBodyMetadata: (
    args: {
      where: GovernmentBodyMetadataWhereUniqueInput;
      create: GovernmentBodyMetadataCreateInput;
      update: GovernmentBodyMetadataUpdateInput;
    }
  ) => GovernmentBodyMetadataPromise;
  deleteGovernmentBodyMetadata: (
    where: GovernmentBodyMetadataWhereUniqueInput
  ) => GovernmentBodyMetadataPromise;
  deleteManyGovernmentBodyMetadatas: (
    where?: GovernmentBodyMetadataWhereInput
  ) => BatchPayloadPromise;
  createGovernmentFacility: (
    data: GovernmentFacilityCreateInput
  ) => GovernmentFacilityPromise;
  updateGovernmentFacility: (
    args: {
      data: GovernmentFacilityUpdateInput;
      where: GovernmentFacilityWhereUniqueInput;
    }
  ) => GovernmentFacilityPromise;
  updateManyGovernmentFacilities: (
    args: {
      data: GovernmentFacilityUpdateManyMutationInput;
      where?: GovernmentFacilityWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGovernmentFacility: (
    args: {
      where: GovernmentFacilityWhereUniqueInput;
      create: GovernmentFacilityCreateInput;
      update: GovernmentFacilityUpdateInput;
    }
  ) => GovernmentFacilityPromise;
  deleteGovernmentFacility: (
    where: GovernmentFacilityWhereUniqueInput
  ) => GovernmentFacilityPromise;
  deleteManyGovernmentFacilities: (
    where?: GovernmentFacilityWhereInput
  ) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateLocation: (
    args: { data: LocationUpdateInput; where: LocationWhereUniqueInput }
  ) => LocationPromise;
  updateManyLocations: (
    args: { data: LocationUpdateManyMutationInput; where?: LocationWhereInput }
  ) => BatchPayloadPromise;
  upsertLocation: (
    args: {
      where: LocationWhereUniqueInput;
      create: LocationCreateInput;
      update: LocationUpdateInput;
    }
  ) => LocationPromise;
  deleteLocation: (where: LocationWhereUniqueInput) => LocationPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createLocationMetadata: (
    data: LocationMetadataCreateInput
  ) => LocationMetadataPromise;
  updateLocationMetadata: (
    args: {
      data: LocationMetadataUpdateInput;
      where: LocationMetadataWhereUniqueInput;
    }
  ) => LocationMetadataPromise;
  updateManyLocationMetadatas: (
    args: {
      data: LocationMetadataUpdateManyMutationInput;
      where?: LocationMetadataWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertLocationMetadata: (
    args: {
      where: LocationMetadataWhereUniqueInput;
      create: LocationMetadataCreateInput;
      update: LocationMetadataUpdateInput;
    }
  ) => LocationMetadataPromise;
  deleteLocationMetadata: (
    where: LocationMetadataWhereUniqueInput
  ) => LocationMetadataPromise;
  deleteManyLocationMetadatas: (
    where?: LocationMetadataWhereInput
  ) => BatchPayloadPromise;
  createPhoneNumber: (data: PhoneNumberCreateInput) => PhoneNumberPromise;
  updatePhoneNumber: (
    args: { data: PhoneNumberUpdateInput; where: PhoneNumberWhereUniqueInput }
  ) => PhoneNumberPromise;
  updateManyPhoneNumbers: (
    args: {
      data: PhoneNumberUpdateManyMutationInput;
      where?: PhoneNumberWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPhoneNumber: (
    args: {
      where: PhoneNumberWhereUniqueInput;
      create: PhoneNumberCreateInput;
      update: PhoneNumberUpdateInput;
    }
  ) => PhoneNumberPromise;
  deletePhoneNumber: (where: PhoneNumberWhereUniqueInput) => PhoneNumberPromise;
  deleteManyPhoneNumbers: (
    where?: PhoneNumberWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserProfile: (data: UserProfileCreateInput) => UserProfilePromise;
  updateUserProfile: (
    args: { data: UserProfileUpdateInput; where: UserProfileWhereUniqueInput }
  ) => UserProfilePromise;
  updateManyUserProfiles: (
    args: {
      data: UserProfileUpdateManyMutationInput;
      where?: UserProfileWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserProfile: (
    args: {
      where: UserProfileWhereUniqueInput;
      create: UserProfileCreateInput;
      update: UserProfileUpdateInput;
    }
  ) => UserProfilePromise;
  deleteUserProfile: (where: UserProfileWhereUniqueInput) => UserProfilePromise;
  deleteManyUserProfiles: (
    where?: UserProfileWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  affiliation: (
    where?: AffiliationSubscriptionWhereInput
  ) => AffiliationSubscriptionPayloadSubscription;
  affiliationRole: (
    where?: AffiliationRoleSubscriptionWhereInput
  ) => AffiliationRoleSubscriptionPayloadSubscription;
  contactMetadata: (
    where?: ContactMetadataSubscriptionWhereInput
  ) => ContactMetadataSubscriptionPayloadSubscription;
  emailAddress: (
    where?: EmailAddressSubscriptionWhereInput
  ) => EmailAddressSubscriptionPayloadSubscription;
  externalLink: (
    where?: ExternalLinkSubscriptionWhereInput
  ) => ExternalLinkSubscriptionPayloadSubscription;
  facilityMetadata: (
    where?: FacilityMetadataSubscriptionWhereInput
  ) => FacilityMetadataSubscriptionPayloadSubscription;
  geometry: (
    where?: GeometrySubscriptionWhereInput
  ) => GeometrySubscriptionPayloadSubscription;
  governmentActor: (
    where?: GovernmentActorSubscriptionWhereInput
  ) => GovernmentActorSubscriptionPayloadSubscription;
  governmentActorProfile: (
    where?: GovernmentActorProfileSubscriptionWhereInput
  ) => GovernmentActorProfileSubscriptionPayloadSubscription;
  governmentBody: (
    where?: GovernmentBodySubscriptionWhereInput
  ) => GovernmentBodySubscriptionPayloadSubscription;
  governmentBodyMetadata: (
    where?: GovernmentBodyMetadataSubscriptionWhereInput
  ) => GovernmentBodyMetadataSubscriptionPayloadSubscription;
  governmentFacility: (
    where?: GovernmentFacilitySubscriptionWhereInput
  ) => GovernmentFacilitySubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  locationMetadata: (
    where?: LocationMetadataSubscriptionWhereInput
  ) => LocationMetadataSubscriptionPayloadSubscription;
  phoneNumber: (
    where?: PhoneNumberSubscriptionWhereInput
  ) => PhoneNumberSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userProfile: (
    where?: UserProfileSubscriptionWhereInput
  ) => UserProfileSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type EmailAddressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "payload_ASC"
  | "payload_DESC";

export type PhoneNumberOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "payload_ASC"
  | "payload_DESC";

export type GovernmentFacilityType =
  | "DETENTION_CENTER"
  | "FIELD_OFFICE"
  | "COURT";

export type AffiliationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dateStarted_ASC"
  | "dateStarted_DESC"
  | "dateEnded_ASC"
  | "dateEnded_DESC"
  | "notes_ASC"
  | "notes_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GovernmentFacilityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "type_ASC"
  | "type_DESC";

export type GovernmentActorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GovernmentBodyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AffiliationRoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "abbr_ASC"
  | "abbr_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ContactMetadataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isPrimary_ASC"
  | "isPrimary_DESC"
  | "isPublic_ASC"
  | "isPublic_DESC"
  | "isVerified_ASC"
  | "isVerified_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExternalLinkOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "payload_ASC"
  | "payload_DESC";

export type FacilityMetadataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isPrimary_ASC"
  | "isPrimary_DESC"
  | "isPublic_ASC"
  | "isPublic_DESC"
  | "isVerified_ASC"
  | "isVerified_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GeometryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "lng_ASC"
  | "lng_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GovernmentActorProfileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC";

export type GovernmentBodyMetadataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "hasChildren_ASC"
  | "hasChildren_DESC"
  | "hasParent_ASC"
  | "hasParent_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "formatted_address_ASC"
  | "formatted_address_DESC"
  | "googleId_ASC"
  | "googleId_DESC"
  | "placeId_ASC"
  | "placeId_DESC";

export type LocationMetadataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isPrimary_ASC"
  | "isPrimary_DESC"
  | "isPublic_ASC"
  | "isPublic_DESC"
  | "isVerified_ASC"
  | "isVerified_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "handle_ASC"
  | "handle_DESC"
  | "cognitoId_ASC"
  | "cognitoId_DESC";

export type UserProfileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "location_ASC"
  | "location_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AffiliationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface EmailAddressWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  payload?: String;
  payload_not?: String;
  payload_in?: String[] | String;
  payload_not_in?: String[] | String;
  payload_lt?: String;
  payload_lte?: String;
  payload_gt?: String;
  payload_gte?: String;
  payload_contains?: String;
  payload_not_contains?: String;
  payload_starts_with?: String;
  payload_not_starts_with?: String;
  payload_ends_with?: String;
  payload_not_ends_with?: String;
  metadata?: ContactMetadataWhereInput;
  AND?: EmailAddressWhereInput[] | EmailAddressWhereInput;
  OR?: EmailAddressWhereInput[] | EmailAddressWhereInput;
  NOT?: EmailAddressWhereInput[] | EmailAddressWhereInput;
}

export interface ContactMetadataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  isPrimary?: Boolean;
  isPrimary_not?: Boolean;
  isPublic?: Boolean;
  isPublic_not?: Boolean;
  isVerified?: Boolean;
  isVerified_not?: Boolean;
  AND?: ContactMetadataWhereInput[] | ContactMetadataWhereInput;
  OR?: ContactMetadataWhereInput[] | ContactMetadataWhereInput;
  NOT?: ContactMetadataWhereInput[] | ContactMetadataWhereInput;
}

export interface PhoneNumberWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  payload?: String;
  payload_not?: String;
  payload_in?: String[] | String;
  payload_not_in?: String[] | String;
  payload_lt?: String;
  payload_lte?: String;
  payload_gt?: String;
  payload_gte?: String;
  payload_contains?: String;
  payload_not_contains?: String;
  payload_starts_with?: String;
  payload_not_starts_with?: String;
  payload_ends_with?: String;
  payload_not_ends_with?: String;
  metadata?: ContactMetadataWhereInput;
  AND?: PhoneNumberWhereInput[] | PhoneNumberWhereInput;
  OR?: PhoneNumberWhereInput[] | PhoneNumberWhereInput;
  NOT?: PhoneNumberWhereInput[] | PhoneNumberWhereInput;
}

export interface AffiliationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  actor?: GovernmentActorWhereInput;
  body?: GovernmentBodyWhereInput;
  dateStarted?: DateTimeInput;
  dateStarted_not?: DateTimeInput;
  dateStarted_in?: DateTimeInput[] | DateTimeInput;
  dateStarted_not_in?: DateTimeInput[] | DateTimeInput;
  dateStarted_lt?: DateTimeInput;
  dateStarted_lte?: DateTimeInput;
  dateStarted_gt?: DateTimeInput;
  dateStarted_gte?: DateTimeInput;
  dateEnded?: DateTimeInput;
  dateEnded_not?: DateTimeInput;
  dateEnded_in?: DateTimeInput[] | DateTimeInput;
  dateEnded_not_in?: DateTimeInput[] | DateTimeInput;
  dateEnded_lt?: DateTimeInput;
  dateEnded_lte?: DateTimeInput;
  dateEnded_gt?: DateTimeInput;
  dateEnded_gte?: DateTimeInput;
  role?: AffiliationRoleWhereInput;
  AND?: AffiliationWhereInput[] | AffiliationWhereInput;
  OR?: AffiliationWhereInput[] | AffiliationWhereInput;
  NOT?: AffiliationWhereInput[] | AffiliationWhereInput;
}

export interface GovernmentActorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  profile?: GovernmentActorProfileWhereInput;
  affiliations_every?: AffiliationWhereInput;
  affiliations_some?: AffiliationWhereInput;
  affiliations_none?: AffiliationWhereInput;
  AND?: GovernmentActorWhereInput[] | GovernmentActorWhereInput;
  OR?: GovernmentActorWhereInput[] | GovernmentActorWhereInput;
  NOT?: GovernmentActorWhereInput[] | GovernmentActorWhereInput;
}

export interface GovernmentActorProfileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  email_every?: EmailAddressWhereInput;
  email_some?: EmailAddressWhereInput;
  email_none?: EmailAddressWhereInput;
  phone_number_every?: PhoneNumberWhereInput;
  phone_number_some?: PhoneNumberWhereInput;
  phone_number_none?: PhoneNumberWhereInput;
  AND?: GovernmentActorProfileWhereInput[] | GovernmentActorProfileWhereInput;
  OR?: GovernmentActorProfileWhereInput[] | GovernmentActorProfileWhereInput;
  NOT?: GovernmentActorProfileWhereInput[] | GovernmentActorProfileWhereInput;
}

export interface GovernmentBodyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  facilities_every?: GovernmentFacilityWhereInput;
  facilities_some?: GovernmentFacilityWhereInput;
  facilities_none?: GovernmentFacilityWhereInput;
  parent?: GovernmentBodyWhereInput;
  children_every?: GovernmentBodyWhereInput;
  children_some?: GovernmentBodyWhereInput;
  children_none?: GovernmentBodyWhereInput;
  metadata?: GovernmentBodyMetadataWhereInput;
  AND?: GovernmentBodyWhereInput[] | GovernmentBodyWhereInput;
  OR?: GovernmentBodyWhereInput[] | GovernmentBodyWhereInput;
  NOT?: GovernmentBodyWhereInput[] | GovernmentBodyWhereInput;
}

export interface GovernmentFacilityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  type?: GovernmentFacilityType;
  type_not?: GovernmentFacilityType;
  type_in?: GovernmentFacilityType[] | GovernmentFacilityType;
  type_not_in?: GovernmentFacilityType[] | GovernmentFacilityType;
  location?: LocationWhereInput;
  actors_every?: GovernmentActorWhereInput;
  actors_some?: GovernmentActorWhereInput;
  actors_none?: GovernmentActorWhereInput;
  phone?: PhoneNumberWhereInput;
  fax?: PhoneNumberWhereInput;
  email?: EmailAddressWhereInput;
  url?: ExternalLinkWhereInput;
  metadata?: FacilityMetadataWhereInput;
  AND?: GovernmentFacilityWhereInput[] | GovernmentFacilityWhereInput;
  OR?: GovernmentFacilityWhereInput[] | GovernmentFacilityWhereInput;
  NOT?: GovernmentFacilityWhereInput[] | GovernmentFacilityWhereInput;
}

export interface LocationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  formatted_address?: String;
  formatted_address_not?: String;
  formatted_address_in?: String[] | String;
  formatted_address_not_in?: String[] | String;
  formatted_address_lt?: String;
  formatted_address_lte?: String;
  formatted_address_gt?: String;
  formatted_address_gte?: String;
  formatted_address_contains?: String;
  formatted_address_not_contains?: String;
  formatted_address_starts_with?: String;
  formatted_address_not_starts_with?: String;
  formatted_address_ends_with?: String;
  formatted_address_not_ends_with?: String;
  googleId?: String;
  googleId_not?: String;
  googleId_in?: String[] | String;
  googleId_not_in?: String[] | String;
  googleId_lt?: String;
  googleId_lte?: String;
  googleId_gt?: String;
  googleId_gte?: String;
  googleId_contains?: String;
  googleId_not_contains?: String;
  googleId_starts_with?: String;
  googleId_not_starts_with?: String;
  googleId_ends_with?: String;
  googleId_not_ends_with?: String;
  placeId?: String;
  placeId_not?: String;
  placeId_in?: String[] | String;
  placeId_not_in?: String[] | String;
  placeId_lt?: String;
  placeId_lte?: String;
  placeId_gt?: String;
  placeId_gte?: String;
  placeId_contains?: String;
  placeId_not_contains?: String;
  placeId_starts_with?: String;
  placeId_not_starts_with?: String;
  placeId_ends_with?: String;
  placeId_not_ends_with?: String;
  location?: GeometryWhereInput;
  metadata?: LocationMetadataWhereInput;
  AND?: LocationWhereInput[] | LocationWhereInput;
  OR?: LocationWhereInput[] | LocationWhereInput;
  NOT?: LocationWhereInput[] | LocationWhereInput;
}

export interface GeometryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  lat?: Float;
  lat_not?: Float;
  lat_in?: Float[] | Float;
  lat_not_in?: Float[] | Float;
  lat_lt?: Float;
  lat_lte?: Float;
  lat_gt?: Float;
  lat_gte?: Float;
  lng?: Float;
  lng_not?: Float;
  lng_in?: Float[] | Float;
  lng_not_in?: Float[] | Float;
  lng_lt?: Float;
  lng_lte?: Float;
  lng_gt?: Float;
  lng_gte?: Float;
  AND?: GeometryWhereInput[] | GeometryWhereInput;
  OR?: GeometryWhereInput[] | GeometryWhereInput;
  NOT?: GeometryWhereInput[] | GeometryWhereInput;
}

export interface LocationMetadataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  isPrimary?: Boolean;
  isPrimary_not?: Boolean;
  isPublic?: Boolean;
  isPublic_not?: Boolean;
  isVerified?: Boolean;
  isVerified_not?: Boolean;
  AND?: LocationMetadataWhereInput[] | LocationMetadataWhereInput;
  OR?: LocationMetadataWhereInput[] | LocationMetadataWhereInput;
  NOT?: LocationMetadataWhereInput[] | LocationMetadataWhereInput;
}

export interface ExternalLinkWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  payload?: String;
  payload_not?: String;
  payload_in?: String[] | String;
  payload_not_in?: String[] | String;
  payload_lt?: String;
  payload_lte?: String;
  payload_gt?: String;
  payload_gte?: String;
  payload_contains?: String;
  payload_not_contains?: String;
  payload_starts_with?: String;
  payload_not_starts_with?: String;
  payload_ends_with?: String;
  payload_not_ends_with?: String;
  metadata?: ContactMetadataWhereInput;
  AND?: ExternalLinkWhereInput[] | ExternalLinkWhereInput;
  OR?: ExternalLinkWhereInput[] | ExternalLinkWhereInput;
  NOT?: ExternalLinkWhereInput[] | ExternalLinkWhereInput;
}

export interface FacilityMetadataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  isPrimary?: Boolean;
  isPrimary_not?: Boolean;
  isPublic?: Boolean;
  isPublic_not?: Boolean;
  isVerified?: Boolean;
  isVerified_not?: Boolean;
  AND?: FacilityMetadataWhereInput[] | FacilityMetadataWhereInput;
  OR?: FacilityMetadataWhereInput[] | FacilityMetadataWhereInput;
  NOT?: FacilityMetadataWhereInput[] | FacilityMetadataWhereInput;
}

export interface GovernmentBodyMetadataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  hasChildren?: Boolean;
  hasChildren_not?: Boolean;
  hasParent?: Boolean;
  hasParent_not?: Boolean;
  AND?: GovernmentBodyMetadataWhereInput[] | GovernmentBodyMetadataWhereInput;
  OR?: GovernmentBodyMetadataWhereInput[] | GovernmentBodyMetadataWhereInput;
  NOT?: GovernmentBodyMetadataWhereInput[] | GovernmentBodyMetadataWhereInput;
}

export interface AffiliationRoleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  body?: GovernmentBodyWhereInput;
  abbr?: String;
  abbr_not?: String;
  abbr_in?: String[] | String;
  abbr_not_in?: String[] | String;
  abbr_lt?: String;
  abbr_lte?: String;
  abbr_gt?: String;
  abbr_gte?: String;
  abbr_contains?: String;
  abbr_not_contains?: String;
  abbr_starts_with?: String;
  abbr_not_starts_with?: String;
  abbr_ends_with?: String;
  abbr_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: AffiliationRoleWhereInput[] | AffiliationRoleWhereInput;
  OR?: AffiliationRoleWhereInput[] | AffiliationRoleWhereInput;
  NOT?: AffiliationRoleWhereInput[] | AffiliationRoleWhereInput;
}

export type AffiliationRoleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ContactMetadataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type EmailAddressWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  payload?: String;
}>;

export type ExternalLinkWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  payload?: String;
}>;

export type FacilityMetadataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type GeometryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type GovernmentActorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type GovernmentActorProfileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type GovernmentBodyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type GovernmentBodyMetadataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type GovernmentFacilityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type LocationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type LocationMetadataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PhoneNumberWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  payload?: String;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  handle?: String;
  cognitoId?: String;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  handle?: String;
  handle_not?: String;
  handle_in?: String[] | String;
  handle_not_in?: String[] | String;
  handle_lt?: String;
  handle_lte?: String;
  handle_gt?: String;
  handle_gte?: String;
  handle_contains?: String;
  handle_not_contains?: String;
  handle_starts_with?: String;
  handle_not_starts_with?: String;
  handle_ends_with?: String;
  handle_not_ends_with?: String;
  cognitoId?: String;
  cognitoId_not?: String;
  cognitoId_in?: String[] | String;
  cognitoId_not_in?: String[] | String;
  cognitoId_lt?: String;
  cognitoId_lte?: String;
  cognitoId_gt?: String;
  cognitoId_gte?: String;
  cognitoId_contains?: String;
  cognitoId_not_contains?: String;
  cognitoId_starts_with?: String;
  cognitoId_not_starts_with?: String;
  cognitoId_ends_with?: String;
  cognitoId_not_ends_with?: String;
  profile?: UserProfileWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface UserProfileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  user?: UserWhereInput;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  email_every?: EmailAddressWhereInput;
  email_some?: EmailAddressWhereInput;
  email_none?: EmailAddressWhereInput;
  phone_number_every?: PhoneNumberWhereInput;
  phone_number_some?: PhoneNumberWhereInput;
  phone_number_none?: PhoneNumberWhereInput;
  AND?: UserProfileWhereInput[] | UserProfileWhereInput;
  OR?: UserProfileWhereInput[] | UserProfileWhereInput;
  NOT?: UserProfileWhereInput[] | UserProfileWhereInput;
}

export type UserProfileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AffiliationCreateInput {
  id?: ID_Input;
  actor: GovernmentActorCreateOneWithoutAffiliationsInput;
  body: GovernmentBodyCreateOneInput;
  dateStarted: DateTimeInput;
  dateEnded?: DateTimeInput;
  role?: AffiliationRoleCreateOneInput;
  notes?: Json;
}

export interface GovernmentActorCreateOneWithoutAffiliationsInput {
  create?: GovernmentActorCreateWithoutAffiliationsInput;
  connect?: GovernmentActorWhereUniqueInput;
}

export interface GovernmentActorCreateWithoutAffiliationsInput {
  id?: ID_Input;
  profile: GovernmentActorProfileCreateOneInput;
}

export interface GovernmentActorProfileCreateOneInput {
  create?: GovernmentActorProfileCreateInput;
  connect?: GovernmentActorProfileWhereUniqueInput;
}

export interface GovernmentActorProfileCreateInput {
  id?: ID_Input;
  firstName?: String;
  lastName?: String;
  email?: EmailAddressCreateManyInput;
  phone_number?: PhoneNumberCreateManyInput;
}

export interface EmailAddressCreateManyInput {
  create?: EmailAddressCreateInput[] | EmailAddressCreateInput;
  connect?: EmailAddressWhereUniqueInput[] | EmailAddressWhereUniqueInput;
}

export interface EmailAddressCreateInput {
  id?: ID_Input;
  payload: String;
  metadata: ContactMetadataCreateOneInput;
}

export interface ContactMetadataCreateOneInput {
  create?: ContactMetadataCreateInput;
  connect?: ContactMetadataWhereUniqueInput;
}

export interface ContactMetadataCreateInput {
  id?: ID_Input;
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface PhoneNumberCreateManyInput {
  create?: PhoneNumberCreateInput[] | PhoneNumberCreateInput;
  connect?: PhoneNumberWhereUniqueInput[] | PhoneNumberWhereUniqueInput;
}

export interface PhoneNumberCreateInput {
  id?: ID_Input;
  payload: String;
  metadata: ContactMetadataCreateOneInput;
}

export interface GovernmentBodyCreateOneInput {
  create?: GovernmentBodyCreateInput;
  connect?: GovernmentBodyWhereUniqueInput;
}

export interface GovernmentBodyCreateInput {
  id?: ID_Input;
  facilities?: GovernmentFacilityCreateManyInput;
  parent?: GovernmentBodyCreateOneWithoutParentInput;
  children?: GovernmentBodyCreateManyWithoutChildrenInput;
  metadata: GovernmentBodyMetadataCreateOneInput;
}

export interface GovernmentFacilityCreateManyInput {
  create?: GovernmentFacilityCreateInput[] | GovernmentFacilityCreateInput;
  connect?:
    | GovernmentFacilityWhereUniqueInput[]
    | GovernmentFacilityWhereUniqueInput;
}

export interface GovernmentFacilityCreateInput {
  id?: ID_Input;
  name?: String;
  type: GovernmentFacilityType;
  location: LocationCreateOneInput;
  actors?: GovernmentActorCreateManyInput;
  phone?: PhoneNumberCreateOneInput;
  fax?: PhoneNumberCreateOneInput;
  email?: EmailAddressCreateOneInput;
  url?: ExternalLinkCreateOneInput;
  metadata: FacilityMetadataCreateOneInput;
}

export interface LocationCreateOneInput {
  create?: LocationCreateInput;
  connect?: LocationWhereUniqueInput;
}

export interface LocationCreateInput {
  id?: ID_Input;
  formatted_address?: String;
  googleId?: String;
  placeId?: String;
  location?: GeometryCreateOneInput;
  metadata: LocationMetadataCreateOneInput;
}

export interface GeometryCreateOneInput {
  create?: GeometryCreateInput;
  connect?: GeometryWhereUniqueInput;
}

export interface GeometryCreateInput {
  id?: ID_Input;
  lat: Float;
  lng: Float;
}

export interface LocationMetadataCreateOneInput {
  create?: LocationMetadataCreateInput;
  connect?: LocationMetadataWhereUniqueInput;
}

export interface LocationMetadataCreateInput {
  id?: ID_Input;
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface GovernmentActorCreateManyInput {
  create?: GovernmentActorCreateInput[] | GovernmentActorCreateInput;
  connect?: GovernmentActorWhereUniqueInput[] | GovernmentActorWhereUniqueInput;
}

export interface GovernmentActorCreateInput {
  id?: ID_Input;
  profile: GovernmentActorProfileCreateOneInput;
  affiliations?: AffiliationCreateManyWithoutActorInput;
}

export interface AffiliationCreateManyWithoutActorInput {
  create?:
    | AffiliationCreateWithoutActorInput[]
    | AffiliationCreateWithoutActorInput;
  connect?: AffiliationWhereUniqueInput[] | AffiliationWhereUniqueInput;
}

export interface AffiliationCreateWithoutActorInput {
  id?: ID_Input;
  body: GovernmentBodyCreateOneInput;
  dateStarted: DateTimeInput;
  dateEnded?: DateTimeInput;
  role?: AffiliationRoleCreateOneInput;
  notes?: Json;
}

export interface AffiliationRoleCreateOneInput {
  create?: AffiliationRoleCreateInput;
  connect?: AffiliationRoleWhereUniqueInput;
}

export interface AffiliationRoleCreateInput {
  id?: ID_Input;
  body: GovernmentBodyCreateOneInput;
  abbr?: String;
  name: String;
}

export interface PhoneNumberCreateOneInput {
  create?: PhoneNumberCreateInput;
  connect?: PhoneNumberWhereUniqueInput;
}

export interface EmailAddressCreateOneInput {
  create?: EmailAddressCreateInput;
  connect?: EmailAddressWhereUniqueInput;
}

export interface ExternalLinkCreateOneInput {
  create?: ExternalLinkCreateInput;
  connect?: ExternalLinkWhereUniqueInput;
}

export interface ExternalLinkCreateInput {
  id?: ID_Input;
  payload: String;
  metadata: ContactMetadataCreateOneInput;
}

export interface FacilityMetadataCreateOneInput {
  create?: FacilityMetadataCreateInput;
  connect?: FacilityMetadataWhereUniqueInput;
}

export interface FacilityMetadataCreateInput {
  id?: ID_Input;
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface GovernmentBodyCreateOneWithoutParentInput {
  create?: GovernmentBodyCreateWithoutParentInput;
  connect?: GovernmentBodyWhereUniqueInput;
}

export interface GovernmentBodyCreateWithoutParentInput {
  id?: ID_Input;
  facilities?: GovernmentFacilityCreateManyInput;
  children?: GovernmentBodyCreateManyWithoutChildrenInput;
  metadata: GovernmentBodyMetadataCreateOneInput;
}

export interface GovernmentBodyCreateManyWithoutChildrenInput {
  create?:
    | GovernmentBodyCreateWithoutChildrenInput[]
    | GovernmentBodyCreateWithoutChildrenInput;
  connect?: GovernmentBodyWhereUniqueInput[] | GovernmentBodyWhereUniqueInput;
}

export interface GovernmentBodyCreateWithoutChildrenInput {
  id?: ID_Input;
  facilities?: GovernmentFacilityCreateManyInput;
  parent?: GovernmentBodyCreateOneWithoutParentInput;
  metadata: GovernmentBodyMetadataCreateOneInput;
}

export interface GovernmentBodyMetadataCreateOneInput {
  create?: GovernmentBodyMetadataCreateInput;
  connect?: GovernmentBodyMetadataWhereUniqueInput;
}

export interface GovernmentBodyMetadataCreateInput {
  id?: ID_Input;
  hasChildren?: Boolean;
  hasParent?: Boolean;
}

export interface AffiliationUpdateInput {
  actor?: GovernmentActorUpdateOneRequiredWithoutAffiliationsInput;
  body?: GovernmentBodyUpdateOneRequiredInput;
  dateStarted?: DateTimeInput;
  dateEnded?: DateTimeInput;
  role?: AffiliationRoleUpdateOneInput;
  notes?: Json;
}

export interface GovernmentActorUpdateOneRequiredWithoutAffiliationsInput {
  create?: GovernmentActorCreateWithoutAffiliationsInput;
  update?: GovernmentActorUpdateWithoutAffiliationsDataInput;
  upsert?: GovernmentActorUpsertWithoutAffiliationsInput;
  connect?: GovernmentActorWhereUniqueInput;
}

export interface GovernmentActorUpdateWithoutAffiliationsDataInput {
  profile?: GovernmentActorProfileUpdateOneRequiredInput;
}

export interface GovernmentActorProfileUpdateOneRequiredInput {
  create?: GovernmentActorProfileCreateInput;
  update?: GovernmentActorProfileUpdateDataInput;
  upsert?: GovernmentActorProfileUpsertNestedInput;
  connect?: GovernmentActorProfileWhereUniqueInput;
}

export interface GovernmentActorProfileUpdateDataInput {
  firstName?: String;
  lastName?: String;
  email?: EmailAddressUpdateManyInput;
  phone_number?: PhoneNumberUpdateManyInput;
}

export interface EmailAddressUpdateManyInput {
  create?: EmailAddressCreateInput[] | EmailAddressCreateInput;
  update?:
    | EmailAddressUpdateWithWhereUniqueNestedInput[]
    | EmailAddressUpdateWithWhereUniqueNestedInput;
  upsert?:
    | EmailAddressUpsertWithWhereUniqueNestedInput[]
    | EmailAddressUpsertWithWhereUniqueNestedInput;
  delete?: EmailAddressWhereUniqueInput[] | EmailAddressWhereUniqueInput;
  connect?: EmailAddressWhereUniqueInput[] | EmailAddressWhereUniqueInput;
  set?: EmailAddressWhereUniqueInput[] | EmailAddressWhereUniqueInput;
  disconnect?: EmailAddressWhereUniqueInput[] | EmailAddressWhereUniqueInput;
  deleteMany?: EmailAddressScalarWhereInput[] | EmailAddressScalarWhereInput;
  updateMany?:
    | EmailAddressUpdateManyWithWhereNestedInput[]
    | EmailAddressUpdateManyWithWhereNestedInput;
}

export interface EmailAddressUpdateWithWhereUniqueNestedInput {
  where: EmailAddressWhereUniqueInput;
  data: EmailAddressUpdateDataInput;
}

export interface EmailAddressUpdateDataInput {
  payload?: String;
  metadata?: ContactMetadataUpdateOneRequiredInput;
}

export interface ContactMetadataUpdateOneRequiredInput {
  create?: ContactMetadataCreateInput;
  update?: ContactMetadataUpdateDataInput;
  upsert?: ContactMetadataUpsertNestedInput;
  connect?: ContactMetadataWhereUniqueInput;
}

export interface ContactMetadataUpdateDataInput {
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface ContactMetadataUpsertNestedInput {
  update: ContactMetadataUpdateDataInput;
  create: ContactMetadataCreateInput;
}

export interface EmailAddressUpsertWithWhereUniqueNestedInput {
  where: EmailAddressWhereUniqueInput;
  update: EmailAddressUpdateDataInput;
  create: EmailAddressCreateInput;
}

export interface EmailAddressScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  payload?: String;
  payload_not?: String;
  payload_in?: String[] | String;
  payload_not_in?: String[] | String;
  payload_lt?: String;
  payload_lte?: String;
  payload_gt?: String;
  payload_gte?: String;
  payload_contains?: String;
  payload_not_contains?: String;
  payload_starts_with?: String;
  payload_not_starts_with?: String;
  payload_ends_with?: String;
  payload_not_ends_with?: String;
  AND?: EmailAddressScalarWhereInput[] | EmailAddressScalarWhereInput;
  OR?: EmailAddressScalarWhereInput[] | EmailAddressScalarWhereInput;
  NOT?: EmailAddressScalarWhereInput[] | EmailAddressScalarWhereInput;
}

export interface EmailAddressUpdateManyWithWhereNestedInput {
  where: EmailAddressScalarWhereInput;
  data: EmailAddressUpdateManyDataInput;
}

export interface EmailAddressUpdateManyDataInput {
  payload?: String;
}

export interface PhoneNumberUpdateManyInput {
  create?: PhoneNumberCreateInput[] | PhoneNumberCreateInput;
  update?:
    | PhoneNumberUpdateWithWhereUniqueNestedInput[]
    | PhoneNumberUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PhoneNumberUpsertWithWhereUniqueNestedInput[]
    | PhoneNumberUpsertWithWhereUniqueNestedInput;
  delete?: PhoneNumberWhereUniqueInput[] | PhoneNumberWhereUniqueInput;
  connect?: PhoneNumberWhereUniqueInput[] | PhoneNumberWhereUniqueInput;
  set?: PhoneNumberWhereUniqueInput[] | PhoneNumberWhereUniqueInput;
  disconnect?: PhoneNumberWhereUniqueInput[] | PhoneNumberWhereUniqueInput;
  deleteMany?: PhoneNumberScalarWhereInput[] | PhoneNumberScalarWhereInput;
  updateMany?:
    | PhoneNumberUpdateManyWithWhereNestedInput[]
    | PhoneNumberUpdateManyWithWhereNestedInput;
}

export interface PhoneNumberUpdateWithWhereUniqueNestedInput {
  where: PhoneNumberWhereUniqueInput;
  data: PhoneNumberUpdateDataInput;
}

export interface PhoneNumberUpdateDataInput {
  payload?: String;
  metadata?: ContactMetadataUpdateOneRequiredInput;
}

export interface PhoneNumberUpsertWithWhereUniqueNestedInput {
  where: PhoneNumberWhereUniqueInput;
  update: PhoneNumberUpdateDataInput;
  create: PhoneNumberCreateInput;
}

export interface PhoneNumberScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  payload?: String;
  payload_not?: String;
  payload_in?: String[] | String;
  payload_not_in?: String[] | String;
  payload_lt?: String;
  payload_lte?: String;
  payload_gt?: String;
  payload_gte?: String;
  payload_contains?: String;
  payload_not_contains?: String;
  payload_starts_with?: String;
  payload_not_starts_with?: String;
  payload_ends_with?: String;
  payload_not_ends_with?: String;
  AND?: PhoneNumberScalarWhereInput[] | PhoneNumberScalarWhereInput;
  OR?: PhoneNumberScalarWhereInput[] | PhoneNumberScalarWhereInput;
  NOT?: PhoneNumberScalarWhereInput[] | PhoneNumberScalarWhereInput;
}

export interface PhoneNumberUpdateManyWithWhereNestedInput {
  where: PhoneNumberScalarWhereInput;
  data: PhoneNumberUpdateManyDataInput;
}

export interface PhoneNumberUpdateManyDataInput {
  payload?: String;
}

export interface GovernmentActorProfileUpsertNestedInput {
  update: GovernmentActorProfileUpdateDataInput;
  create: GovernmentActorProfileCreateInput;
}

export interface GovernmentActorUpsertWithoutAffiliationsInput {
  update: GovernmentActorUpdateWithoutAffiliationsDataInput;
  create: GovernmentActorCreateWithoutAffiliationsInput;
}

export interface GovernmentBodyUpdateOneRequiredInput {
  create?: GovernmentBodyCreateInput;
  update?: GovernmentBodyUpdateDataInput;
  upsert?: GovernmentBodyUpsertNestedInput;
  connect?: GovernmentBodyWhereUniqueInput;
}

export interface GovernmentBodyUpdateDataInput {
  facilities?: GovernmentFacilityUpdateManyInput;
  parent?: GovernmentBodyUpdateOneWithoutParentInput;
  children?: GovernmentBodyUpdateManyWithoutChildrenInput;
  metadata?: GovernmentBodyMetadataUpdateOneRequiredInput;
}

export interface GovernmentFacilityUpdateManyInput {
  create?: GovernmentFacilityCreateInput[] | GovernmentFacilityCreateInput;
  update?:
    | GovernmentFacilityUpdateWithWhereUniqueNestedInput[]
    | GovernmentFacilityUpdateWithWhereUniqueNestedInput;
  upsert?:
    | GovernmentFacilityUpsertWithWhereUniqueNestedInput[]
    | GovernmentFacilityUpsertWithWhereUniqueNestedInput;
  delete?:
    | GovernmentFacilityWhereUniqueInput[]
    | GovernmentFacilityWhereUniqueInput;
  connect?:
    | GovernmentFacilityWhereUniqueInput[]
    | GovernmentFacilityWhereUniqueInput;
  set?:
    | GovernmentFacilityWhereUniqueInput[]
    | GovernmentFacilityWhereUniqueInput;
  disconnect?:
    | GovernmentFacilityWhereUniqueInput[]
    | GovernmentFacilityWhereUniqueInput;
  deleteMany?:
    | GovernmentFacilityScalarWhereInput[]
    | GovernmentFacilityScalarWhereInput;
  updateMany?:
    | GovernmentFacilityUpdateManyWithWhereNestedInput[]
    | GovernmentFacilityUpdateManyWithWhereNestedInput;
}

export interface GovernmentFacilityUpdateWithWhereUniqueNestedInput {
  where: GovernmentFacilityWhereUniqueInput;
  data: GovernmentFacilityUpdateDataInput;
}

export interface GovernmentFacilityUpdateDataInput {
  name?: String;
  type?: GovernmentFacilityType;
  location?: LocationUpdateOneRequiredInput;
  actors?: GovernmentActorUpdateManyInput;
  phone?: PhoneNumberUpdateOneInput;
  fax?: PhoneNumberUpdateOneInput;
  email?: EmailAddressUpdateOneInput;
  url?: ExternalLinkUpdateOneInput;
  metadata?: FacilityMetadataUpdateOneRequiredInput;
}

export interface LocationUpdateOneRequiredInput {
  create?: LocationCreateInput;
  update?: LocationUpdateDataInput;
  upsert?: LocationUpsertNestedInput;
  connect?: LocationWhereUniqueInput;
}

export interface LocationUpdateDataInput {
  formatted_address?: String;
  googleId?: String;
  placeId?: String;
  location?: GeometryUpdateOneInput;
  metadata?: LocationMetadataUpdateOneRequiredInput;
}

export interface GeometryUpdateOneInput {
  create?: GeometryCreateInput;
  update?: GeometryUpdateDataInput;
  upsert?: GeometryUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: GeometryWhereUniqueInput;
}

export interface GeometryUpdateDataInput {
  lat?: Float;
  lng?: Float;
}

export interface GeometryUpsertNestedInput {
  update: GeometryUpdateDataInput;
  create: GeometryCreateInput;
}

export interface LocationMetadataUpdateOneRequiredInput {
  create?: LocationMetadataCreateInput;
  update?: LocationMetadataUpdateDataInput;
  upsert?: LocationMetadataUpsertNestedInput;
  connect?: LocationMetadataWhereUniqueInput;
}

export interface LocationMetadataUpdateDataInput {
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface LocationMetadataUpsertNestedInput {
  update: LocationMetadataUpdateDataInput;
  create: LocationMetadataCreateInput;
}

export interface LocationUpsertNestedInput {
  update: LocationUpdateDataInput;
  create: LocationCreateInput;
}

export interface GovernmentActorUpdateManyInput {
  create?: GovernmentActorCreateInput[] | GovernmentActorCreateInput;
  update?:
    | GovernmentActorUpdateWithWhereUniqueNestedInput[]
    | GovernmentActorUpdateWithWhereUniqueNestedInput;
  upsert?:
    | GovernmentActorUpsertWithWhereUniqueNestedInput[]
    | GovernmentActorUpsertWithWhereUniqueNestedInput;
  delete?: GovernmentActorWhereUniqueInput[] | GovernmentActorWhereUniqueInput;
  connect?: GovernmentActorWhereUniqueInput[] | GovernmentActorWhereUniqueInput;
  set?: GovernmentActorWhereUniqueInput[] | GovernmentActorWhereUniqueInput;
  disconnect?:
    | GovernmentActorWhereUniqueInput[]
    | GovernmentActorWhereUniqueInput;
  deleteMany?:
    | GovernmentActorScalarWhereInput[]
    | GovernmentActorScalarWhereInput;
}

export interface GovernmentActorUpdateWithWhereUniqueNestedInput {
  where: GovernmentActorWhereUniqueInput;
  data: GovernmentActorUpdateDataInput;
}

export interface GovernmentActorUpdateDataInput {
  profile?: GovernmentActorProfileUpdateOneRequiredInput;
  affiliations?: AffiliationUpdateManyWithoutActorInput;
}

export interface AffiliationUpdateManyWithoutActorInput {
  create?:
    | AffiliationCreateWithoutActorInput[]
    | AffiliationCreateWithoutActorInput;
  delete?: AffiliationWhereUniqueInput[] | AffiliationWhereUniqueInput;
  connect?: AffiliationWhereUniqueInput[] | AffiliationWhereUniqueInput;
  set?: AffiliationWhereUniqueInput[] | AffiliationWhereUniqueInput;
  disconnect?: AffiliationWhereUniqueInput[] | AffiliationWhereUniqueInput;
  update?:
    | AffiliationUpdateWithWhereUniqueWithoutActorInput[]
    | AffiliationUpdateWithWhereUniqueWithoutActorInput;
  upsert?:
    | AffiliationUpsertWithWhereUniqueWithoutActorInput[]
    | AffiliationUpsertWithWhereUniqueWithoutActorInput;
  deleteMany?: AffiliationScalarWhereInput[] | AffiliationScalarWhereInput;
  updateMany?:
    | AffiliationUpdateManyWithWhereNestedInput[]
    | AffiliationUpdateManyWithWhereNestedInput;
}

export interface AffiliationUpdateWithWhereUniqueWithoutActorInput {
  where: AffiliationWhereUniqueInput;
  data: AffiliationUpdateWithoutActorDataInput;
}

export interface AffiliationUpdateWithoutActorDataInput {
  body?: GovernmentBodyUpdateOneRequiredInput;
  dateStarted?: DateTimeInput;
  dateEnded?: DateTimeInput;
  role?: AffiliationRoleUpdateOneInput;
  notes?: Json;
}

export interface AffiliationRoleUpdateOneInput {
  create?: AffiliationRoleCreateInput;
  update?: AffiliationRoleUpdateDataInput;
  upsert?: AffiliationRoleUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AffiliationRoleWhereUniqueInput;
}

export interface AffiliationRoleUpdateDataInput {
  body?: GovernmentBodyUpdateOneRequiredInput;
  abbr?: String;
  name?: String;
}

export interface AffiliationRoleUpsertNestedInput {
  update: AffiliationRoleUpdateDataInput;
  create: AffiliationRoleCreateInput;
}

export interface AffiliationUpsertWithWhereUniqueWithoutActorInput {
  where: AffiliationWhereUniqueInput;
  update: AffiliationUpdateWithoutActorDataInput;
  create: AffiliationCreateWithoutActorInput;
}

export interface AffiliationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  dateStarted?: DateTimeInput;
  dateStarted_not?: DateTimeInput;
  dateStarted_in?: DateTimeInput[] | DateTimeInput;
  dateStarted_not_in?: DateTimeInput[] | DateTimeInput;
  dateStarted_lt?: DateTimeInput;
  dateStarted_lte?: DateTimeInput;
  dateStarted_gt?: DateTimeInput;
  dateStarted_gte?: DateTimeInput;
  dateEnded?: DateTimeInput;
  dateEnded_not?: DateTimeInput;
  dateEnded_in?: DateTimeInput[] | DateTimeInput;
  dateEnded_not_in?: DateTimeInput[] | DateTimeInput;
  dateEnded_lt?: DateTimeInput;
  dateEnded_lte?: DateTimeInput;
  dateEnded_gt?: DateTimeInput;
  dateEnded_gte?: DateTimeInput;
  AND?: AffiliationScalarWhereInput[] | AffiliationScalarWhereInput;
  OR?: AffiliationScalarWhereInput[] | AffiliationScalarWhereInput;
  NOT?: AffiliationScalarWhereInput[] | AffiliationScalarWhereInput;
}

export interface AffiliationUpdateManyWithWhereNestedInput {
  where: AffiliationScalarWhereInput;
  data: AffiliationUpdateManyDataInput;
}

export interface AffiliationUpdateManyDataInput {
  dateStarted?: DateTimeInput;
  dateEnded?: DateTimeInput;
  notes?: Json;
}

export interface GovernmentActorUpsertWithWhereUniqueNestedInput {
  where: GovernmentActorWhereUniqueInput;
  update: GovernmentActorUpdateDataInput;
  create: GovernmentActorCreateInput;
}

export interface GovernmentActorScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: GovernmentActorScalarWhereInput[] | GovernmentActorScalarWhereInput;
  OR?: GovernmentActorScalarWhereInput[] | GovernmentActorScalarWhereInput;
  NOT?: GovernmentActorScalarWhereInput[] | GovernmentActorScalarWhereInput;
}

export interface PhoneNumberUpdateOneInput {
  create?: PhoneNumberCreateInput;
  update?: PhoneNumberUpdateDataInput;
  upsert?: PhoneNumberUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PhoneNumberWhereUniqueInput;
}

export interface PhoneNumberUpsertNestedInput {
  update: PhoneNumberUpdateDataInput;
  create: PhoneNumberCreateInput;
}

export interface EmailAddressUpdateOneInput {
  create?: EmailAddressCreateInput;
  update?: EmailAddressUpdateDataInput;
  upsert?: EmailAddressUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EmailAddressWhereUniqueInput;
}

export interface EmailAddressUpsertNestedInput {
  update: EmailAddressUpdateDataInput;
  create: EmailAddressCreateInput;
}

export interface ExternalLinkUpdateOneInput {
  create?: ExternalLinkCreateInput;
  update?: ExternalLinkUpdateDataInput;
  upsert?: ExternalLinkUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExternalLinkWhereUniqueInput;
}

export interface ExternalLinkUpdateDataInput {
  payload?: String;
  metadata?: ContactMetadataUpdateOneRequiredInput;
}

export interface ExternalLinkUpsertNestedInput {
  update: ExternalLinkUpdateDataInput;
  create: ExternalLinkCreateInput;
}

export interface FacilityMetadataUpdateOneRequiredInput {
  create?: FacilityMetadataCreateInput;
  update?: FacilityMetadataUpdateDataInput;
  upsert?: FacilityMetadataUpsertNestedInput;
  connect?: FacilityMetadataWhereUniqueInput;
}

export interface FacilityMetadataUpdateDataInput {
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface FacilityMetadataUpsertNestedInput {
  update: FacilityMetadataUpdateDataInput;
  create: FacilityMetadataCreateInput;
}

export interface GovernmentFacilityUpsertWithWhereUniqueNestedInput {
  where: GovernmentFacilityWhereUniqueInput;
  update: GovernmentFacilityUpdateDataInput;
  create: GovernmentFacilityCreateInput;
}

export interface GovernmentFacilityScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  type?: GovernmentFacilityType;
  type_not?: GovernmentFacilityType;
  type_in?: GovernmentFacilityType[] | GovernmentFacilityType;
  type_not_in?: GovernmentFacilityType[] | GovernmentFacilityType;
  AND?:
    | GovernmentFacilityScalarWhereInput[]
    | GovernmentFacilityScalarWhereInput;
  OR?:
    | GovernmentFacilityScalarWhereInput[]
    | GovernmentFacilityScalarWhereInput;
  NOT?:
    | GovernmentFacilityScalarWhereInput[]
    | GovernmentFacilityScalarWhereInput;
}

export interface GovernmentFacilityUpdateManyWithWhereNestedInput {
  where: GovernmentFacilityScalarWhereInput;
  data: GovernmentFacilityUpdateManyDataInput;
}

export interface GovernmentFacilityUpdateManyDataInput {
  name?: String;
  type?: GovernmentFacilityType;
}

export interface GovernmentBodyUpdateOneWithoutParentInput {
  create?: GovernmentBodyCreateWithoutParentInput;
  update?: GovernmentBodyUpdateWithoutParentDataInput;
  upsert?: GovernmentBodyUpsertWithoutParentInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: GovernmentBodyWhereUniqueInput;
}

export interface GovernmentBodyUpdateWithoutParentDataInput {
  facilities?: GovernmentFacilityUpdateManyInput;
  children?: GovernmentBodyUpdateManyWithoutChildrenInput;
  metadata?: GovernmentBodyMetadataUpdateOneRequiredInput;
}

export interface GovernmentBodyUpdateManyWithoutChildrenInput {
  create?:
    | GovernmentBodyCreateWithoutChildrenInput[]
    | GovernmentBodyCreateWithoutChildrenInput;
  delete?: GovernmentBodyWhereUniqueInput[] | GovernmentBodyWhereUniqueInput;
  connect?: GovernmentBodyWhereUniqueInput[] | GovernmentBodyWhereUniqueInput;
  set?: GovernmentBodyWhereUniqueInput[] | GovernmentBodyWhereUniqueInput;
  disconnect?:
    | GovernmentBodyWhereUniqueInput[]
    | GovernmentBodyWhereUniqueInput;
  update?:
    | GovernmentBodyUpdateWithWhereUniqueWithoutChildrenInput[]
    | GovernmentBodyUpdateWithWhereUniqueWithoutChildrenInput;
  upsert?:
    | GovernmentBodyUpsertWithWhereUniqueWithoutChildrenInput[]
    | GovernmentBodyUpsertWithWhereUniqueWithoutChildrenInput;
  deleteMany?:
    | GovernmentBodyScalarWhereInput[]
    | GovernmentBodyScalarWhereInput;
}

export interface GovernmentBodyUpdateWithWhereUniqueWithoutChildrenInput {
  where: GovernmentBodyWhereUniqueInput;
  data: GovernmentBodyUpdateWithoutChildrenDataInput;
}

export interface GovernmentBodyUpdateWithoutChildrenDataInput {
  facilities?: GovernmentFacilityUpdateManyInput;
  parent?: GovernmentBodyUpdateOneWithoutParentInput;
  metadata?: GovernmentBodyMetadataUpdateOneRequiredInput;
}

export interface GovernmentBodyMetadataUpdateOneRequiredInput {
  create?: GovernmentBodyMetadataCreateInput;
  update?: GovernmentBodyMetadataUpdateDataInput;
  upsert?: GovernmentBodyMetadataUpsertNestedInput;
  connect?: GovernmentBodyMetadataWhereUniqueInput;
}

export interface GovernmentBodyMetadataUpdateDataInput {
  hasChildren?: Boolean;
  hasParent?: Boolean;
}

export interface GovernmentBodyMetadataUpsertNestedInput {
  update: GovernmentBodyMetadataUpdateDataInput;
  create: GovernmentBodyMetadataCreateInput;
}

export interface GovernmentBodyUpsertWithWhereUniqueWithoutChildrenInput {
  where: GovernmentBodyWhereUniqueInput;
  update: GovernmentBodyUpdateWithoutChildrenDataInput;
  create: GovernmentBodyCreateWithoutChildrenInput;
}

export interface GovernmentBodyScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: GovernmentBodyScalarWhereInput[] | GovernmentBodyScalarWhereInput;
  OR?: GovernmentBodyScalarWhereInput[] | GovernmentBodyScalarWhereInput;
  NOT?: GovernmentBodyScalarWhereInput[] | GovernmentBodyScalarWhereInput;
}

export interface GovernmentBodyUpsertWithoutParentInput {
  update: GovernmentBodyUpdateWithoutParentDataInput;
  create: GovernmentBodyCreateWithoutParentInput;
}

export interface GovernmentBodyUpsertNestedInput {
  update: GovernmentBodyUpdateDataInput;
  create: GovernmentBodyCreateInput;
}

export interface AffiliationUpdateManyMutationInput {
  dateStarted?: DateTimeInput;
  dateEnded?: DateTimeInput;
  notes?: Json;
}

export interface AffiliationRoleUpdateInput {
  body?: GovernmentBodyUpdateOneRequiredInput;
  abbr?: String;
  name?: String;
}

export interface AffiliationRoleUpdateManyMutationInput {
  abbr?: String;
  name?: String;
}

export interface ContactMetadataUpdateInput {
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface ContactMetadataUpdateManyMutationInput {
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface EmailAddressUpdateInput {
  payload?: String;
  metadata?: ContactMetadataUpdateOneRequiredInput;
}

export interface EmailAddressUpdateManyMutationInput {
  payload?: String;
}

export interface ExternalLinkUpdateInput {
  payload?: String;
  metadata?: ContactMetadataUpdateOneRequiredInput;
}

export interface ExternalLinkUpdateManyMutationInput {
  payload?: String;
}

export interface FacilityMetadataUpdateInput {
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface FacilityMetadataUpdateManyMutationInput {
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface GeometryUpdateInput {
  lat?: Float;
  lng?: Float;
}

export interface GeometryUpdateManyMutationInput {
  lat?: Float;
  lng?: Float;
}

export interface GovernmentActorUpdateInput {
  profile?: GovernmentActorProfileUpdateOneRequiredInput;
  affiliations?: AffiliationUpdateManyWithoutActorInput;
}

export interface GovernmentActorProfileUpdateInput {
  firstName?: String;
  lastName?: String;
  email?: EmailAddressUpdateManyInput;
  phone_number?: PhoneNumberUpdateManyInput;
}

export interface GovernmentActorProfileUpdateManyMutationInput {
  firstName?: String;
  lastName?: String;
}

export interface GovernmentBodyUpdateInput {
  facilities?: GovernmentFacilityUpdateManyInput;
  parent?: GovernmentBodyUpdateOneWithoutParentInput;
  children?: GovernmentBodyUpdateManyWithoutChildrenInput;
  metadata?: GovernmentBodyMetadataUpdateOneRequiredInput;
}

export interface GovernmentBodyMetadataUpdateInput {
  hasChildren?: Boolean;
  hasParent?: Boolean;
}

export interface GovernmentBodyMetadataUpdateManyMutationInput {
  hasChildren?: Boolean;
  hasParent?: Boolean;
}

export interface GovernmentFacilityUpdateInput {
  name?: String;
  type?: GovernmentFacilityType;
  location?: LocationUpdateOneRequiredInput;
  actors?: GovernmentActorUpdateManyInput;
  phone?: PhoneNumberUpdateOneInput;
  fax?: PhoneNumberUpdateOneInput;
  email?: EmailAddressUpdateOneInput;
  url?: ExternalLinkUpdateOneInput;
  metadata?: FacilityMetadataUpdateOneRequiredInput;
}

export interface GovernmentFacilityUpdateManyMutationInput {
  name?: String;
  type?: GovernmentFacilityType;
}

export interface LocationUpdateInput {
  formatted_address?: String;
  googleId?: String;
  placeId?: String;
  location?: GeometryUpdateOneInput;
  metadata?: LocationMetadataUpdateOneRequiredInput;
}

export interface LocationUpdateManyMutationInput {
  formatted_address?: String;
  googleId?: String;
  placeId?: String;
}

export interface LocationMetadataUpdateInput {
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface LocationMetadataUpdateManyMutationInput {
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface PhoneNumberUpdateInput {
  payload?: String;
  metadata?: ContactMetadataUpdateOneRequiredInput;
}

export interface PhoneNumberUpdateManyMutationInput {
  payload?: String;
}

export interface UserCreateInput {
  id?: ID_Input;
  handle?: String;
  cognitoId: String;
  profile: UserProfileCreateOneWithoutUserInput;
}

export interface UserProfileCreateOneWithoutUserInput {
  create?: UserProfileCreateWithoutUserInput;
  connect?: UserProfileWhereUniqueInput;
}

export interface UserProfileCreateWithoutUserInput {
  id?: ID_Input;
  firstName?: String;
  lastName?: String;
  avatar?: String;
  location?: String;
  email?: EmailAddressCreateManyInput;
  phone_number?: PhoneNumberCreateManyInput;
}

export interface UserUpdateInput {
  handle?: String;
  cognitoId?: String;
  profile?: UserProfileUpdateOneRequiredWithoutUserInput;
}

export interface UserProfileUpdateOneRequiredWithoutUserInput {
  create?: UserProfileCreateWithoutUserInput;
  update?: UserProfileUpdateWithoutUserDataInput;
  upsert?: UserProfileUpsertWithoutUserInput;
  connect?: UserProfileWhereUniqueInput;
}

export interface UserProfileUpdateWithoutUserDataInput {
  firstName?: String;
  lastName?: String;
  avatar?: String;
  location?: String;
  email?: EmailAddressUpdateManyInput;
  phone_number?: PhoneNumberUpdateManyInput;
}

export interface UserProfileUpsertWithoutUserInput {
  update: UserProfileUpdateWithoutUserDataInput;
  create: UserProfileCreateWithoutUserInput;
}

export interface UserUpdateManyMutationInput {
  handle?: String;
  cognitoId?: String;
}

export interface UserProfileCreateInput {
  id?: ID_Input;
  user: UserCreateOneWithoutProfileInput;
  firstName?: String;
  lastName?: String;
  avatar?: String;
  location?: String;
  email?: EmailAddressCreateManyInput;
  phone_number?: PhoneNumberCreateManyInput;
}

export interface UserCreateOneWithoutProfileInput {
  create?: UserCreateWithoutProfileInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutProfileInput {
  id?: ID_Input;
  handle?: String;
  cognitoId: String;
}

export interface UserProfileUpdateInput {
  user?: UserUpdateOneRequiredWithoutProfileInput;
  firstName?: String;
  lastName?: String;
  avatar?: String;
  location?: String;
  email?: EmailAddressUpdateManyInput;
  phone_number?: PhoneNumberUpdateManyInput;
}

export interface UserUpdateOneRequiredWithoutProfileInput {
  create?: UserCreateWithoutProfileInput;
  update?: UserUpdateWithoutProfileDataInput;
  upsert?: UserUpsertWithoutProfileInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutProfileDataInput {
  handle?: String;
  cognitoId?: String;
}

export interface UserUpsertWithoutProfileInput {
  update: UserUpdateWithoutProfileDataInput;
  create: UserCreateWithoutProfileInput;
}

export interface UserProfileUpdateManyMutationInput {
  firstName?: String;
  lastName?: String;
  avatar?: String;
  location?: String;
}

export interface AffiliationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AffiliationWhereInput;
  AND?: AffiliationSubscriptionWhereInput[] | AffiliationSubscriptionWhereInput;
  OR?: AffiliationSubscriptionWhereInput[] | AffiliationSubscriptionWhereInput;
  NOT?: AffiliationSubscriptionWhereInput[] | AffiliationSubscriptionWhereInput;
}

export interface AffiliationRoleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AffiliationRoleWhereInput;
  AND?:
    | AffiliationRoleSubscriptionWhereInput[]
    | AffiliationRoleSubscriptionWhereInput;
  OR?:
    | AffiliationRoleSubscriptionWhereInput[]
    | AffiliationRoleSubscriptionWhereInput;
  NOT?:
    | AffiliationRoleSubscriptionWhereInput[]
    | AffiliationRoleSubscriptionWhereInput;
}

export interface ContactMetadataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ContactMetadataWhereInput;
  AND?:
    | ContactMetadataSubscriptionWhereInput[]
    | ContactMetadataSubscriptionWhereInput;
  OR?:
    | ContactMetadataSubscriptionWhereInput[]
    | ContactMetadataSubscriptionWhereInput;
  NOT?:
    | ContactMetadataSubscriptionWhereInput[]
    | ContactMetadataSubscriptionWhereInput;
}

export interface EmailAddressSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EmailAddressWhereInput;
  AND?:
    | EmailAddressSubscriptionWhereInput[]
    | EmailAddressSubscriptionWhereInput;
  OR?:
    | EmailAddressSubscriptionWhereInput[]
    | EmailAddressSubscriptionWhereInput;
  NOT?:
    | EmailAddressSubscriptionWhereInput[]
    | EmailAddressSubscriptionWhereInput;
}

export interface ExternalLinkSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExternalLinkWhereInput;
  AND?:
    | ExternalLinkSubscriptionWhereInput[]
    | ExternalLinkSubscriptionWhereInput;
  OR?:
    | ExternalLinkSubscriptionWhereInput[]
    | ExternalLinkSubscriptionWhereInput;
  NOT?:
    | ExternalLinkSubscriptionWhereInput[]
    | ExternalLinkSubscriptionWhereInput;
}

export interface FacilityMetadataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FacilityMetadataWhereInput;
  AND?:
    | FacilityMetadataSubscriptionWhereInput[]
    | FacilityMetadataSubscriptionWhereInput;
  OR?:
    | FacilityMetadataSubscriptionWhereInput[]
    | FacilityMetadataSubscriptionWhereInput;
  NOT?:
    | FacilityMetadataSubscriptionWhereInput[]
    | FacilityMetadataSubscriptionWhereInput;
}

export interface GeometrySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GeometryWhereInput;
  AND?: GeometrySubscriptionWhereInput[] | GeometrySubscriptionWhereInput;
  OR?: GeometrySubscriptionWhereInput[] | GeometrySubscriptionWhereInput;
  NOT?: GeometrySubscriptionWhereInput[] | GeometrySubscriptionWhereInput;
}

export interface GovernmentActorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GovernmentActorWhereInput;
  AND?:
    | GovernmentActorSubscriptionWhereInput[]
    | GovernmentActorSubscriptionWhereInput;
  OR?:
    | GovernmentActorSubscriptionWhereInput[]
    | GovernmentActorSubscriptionWhereInput;
  NOT?:
    | GovernmentActorSubscriptionWhereInput[]
    | GovernmentActorSubscriptionWhereInput;
}

export interface GovernmentActorProfileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GovernmentActorProfileWhereInput;
  AND?:
    | GovernmentActorProfileSubscriptionWhereInput[]
    | GovernmentActorProfileSubscriptionWhereInput;
  OR?:
    | GovernmentActorProfileSubscriptionWhereInput[]
    | GovernmentActorProfileSubscriptionWhereInput;
  NOT?:
    | GovernmentActorProfileSubscriptionWhereInput[]
    | GovernmentActorProfileSubscriptionWhereInput;
}

export interface GovernmentBodySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GovernmentBodyWhereInput;
  AND?:
    | GovernmentBodySubscriptionWhereInput[]
    | GovernmentBodySubscriptionWhereInput;
  OR?:
    | GovernmentBodySubscriptionWhereInput[]
    | GovernmentBodySubscriptionWhereInput;
  NOT?:
    | GovernmentBodySubscriptionWhereInput[]
    | GovernmentBodySubscriptionWhereInput;
}

export interface GovernmentBodyMetadataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GovernmentBodyMetadataWhereInput;
  AND?:
    | GovernmentBodyMetadataSubscriptionWhereInput[]
    | GovernmentBodyMetadataSubscriptionWhereInput;
  OR?:
    | GovernmentBodyMetadataSubscriptionWhereInput[]
    | GovernmentBodyMetadataSubscriptionWhereInput;
  NOT?:
    | GovernmentBodyMetadataSubscriptionWhereInput[]
    | GovernmentBodyMetadataSubscriptionWhereInput;
}

export interface GovernmentFacilitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GovernmentFacilityWhereInput;
  AND?:
    | GovernmentFacilitySubscriptionWhereInput[]
    | GovernmentFacilitySubscriptionWhereInput;
  OR?:
    | GovernmentFacilitySubscriptionWhereInput[]
    | GovernmentFacilitySubscriptionWhereInput;
  NOT?:
    | GovernmentFacilitySubscriptionWhereInput[]
    | GovernmentFacilitySubscriptionWhereInput;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LocationWhereInput;
  AND?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  OR?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  NOT?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
}

export interface LocationMetadataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LocationMetadataWhereInput;
  AND?:
    | LocationMetadataSubscriptionWhereInput[]
    | LocationMetadataSubscriptionWhereInput;
  OR?:
    | LocationMetadataSubscriptionWhereInput[]
    | LocationMetadataSubscriptionWhereInput;
  NOT?:
    | LocationMetadataSubscriptionWhereInput[]
    | LocationMetadataSubscriptionWhereInput;
}

export interface PhoneNumberSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PhoneNumberWhereInput;
  AND?: PhoneNumberSubscriptionWhereInput[] | PhoneNumberSubscriptionWhereInput;
  OR?: PhoneNumberSubscriptionWhereInput[] | PhoneNumberSubscriptionWhereInput;
  NOT?: PhoneNumberSubscriptionWhereInput[] | PhoneNumberSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface UserProfileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserProfileWhereInput;
  AND?: UserProfileSubscriptionWhereInput[] | UserProfileSubscriptionWhereInput;
  OR?: UserProfileSubscriptionWhereInput[] | UserProfileSubscriptionWhereInput;
  NOT?: UserProfileSubscriptionWhereInput[] | UserProfileSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Affiliation {
  id: ID_Output;
  dateStarted: DateTimeOutput;
  dateEnded?: DateTimeOutput;
  notes?: Json;
}

export interface AffiliationPromise extends Promise<Affiliation>, Fragmentable {
  id: () => Promise<ID_Output>;
  actor: <T = GovernmentActorPromise>() => T;
  body: <T = GovernmentBodyPromise>() => T;
  dateStarted: () => Promise<DateTimeOutput>;
  dateEnded: () => Promise<DateTimeOutput>;
  role: <T = AffiliationRolePromise>() => T;
  notes: () => Promise<Json>;
}

export interface AffiliationSubscription
  extends Promise<AsyncIterator<Affiliation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  actor: <T = GovernmentActorSubscription>() => T;
  body: <T = GovernmentBodySubscription>() => T;
  dateStarted: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateEnded: () => Promise<AsyncIterator<DateTimeOutput>>;
  role: <T = AffiliationRoleSubscription>() => T;
  notes: () => Promise<AsyncIterator<Json>>;
}

export interface GovernmentActor {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GovernmentActorPromise
  extends Promise<GovernmentActor>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  profile: <T = GovernmentActorProfilePromise>() => T;
  affiliations: <T = FragmentableArray<Affiliation>>(
    args?: {
      where?: AffiliationWhereInput;
      orderBy?: AffiliationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GovernmentActorSubscription
  extends Promise<AsyncIterator<GovernmentActor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  profile: <T = GovernmentActorProfileSubscription>() => T;
  affiliations: <T = Promise<AsyncIterator<AffiliationSubscription>>>(
    args?: {
      where?: AffiliationWhereInput;
      orderBy?: AffiliationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GovernmentActorProfile {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName?: String;
  lastName?: String;
}

export interface GovernmentActorProfilePromise
  extends Promise<GovernmentActorProfile>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: <T = FragmentableArray<EmailAddress>>(
    args?: {
      where?: EmailAddressWhereInput;
      orderBy?: EmailAddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  phone_number: <T = FragmentableArray<PhoneNumber>>(
    args?: {
      where?: PhoneNumberWhereInput;
      orderBy?: PhoneNumberOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GovernmentActorProfileSubscription
  extends Promise<AsyncIterator<GovernmentActorProfile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: <T = Promise<AsyncIterator<EmailAddressSubscription>>>(
    args?: {
      where?: EmailAddressWhereInput;
      orderBy?: EmailAddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  phone_number: <T = Promise<AsyncIterator<PhoneNumberSubscription>>>(
    args?: {
      where?: PhoneNumberWhereInput;
      orderBy?: PhoneNumberOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EmailAddress {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  payload: String;
}

export interface EmailAddressPromise
  extends Promise<EmailAddress>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  payload: () => Promise<String>;
  metadata: <T = ContactMetadataPromise>() => T;
}

export interface EmailAddressSubscription
  extends Promise<AsyncIterator<EmailAddress>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  payload: () => Promise<AsyncIterator<String>>;
  metadata: <T = ContactMetadataSubscription>() => T;
}

export interface ContactMetadata {
  id: ID_Output;
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface ContactMetadataPromise
  extends Promise<ContactMetadata>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isPrimary: () => Promise<Boolean>;
  isPublic: () => Promise<Boolean>;
  isVerified: () => Promise<Boolean>;
}

export interface ContactMetadataSubscription
  extends Promise<AsyncIterator<ContactMetadata>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isPrimary: () => Promise<AsyncIterator<Boolean>>;
  isPublic: () => Promise<AsyncIterator<Boolean>>;
  isVerified: () => Promise<AsyncIterator<Boolean>>;
}

export interface PhoneNumber {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  payload: String;
}

export interface PhoneNumberPromise extends Promise<PhoneNumber>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  payload: () => Promise<String>;
  metadata: <T = ContactMetadataPromise>() => T;
}

export interface PhoneNumberSubscription
  extends Promise<AsyncIterator<PhoneNumber>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  payload: () => Promise<AsyncIterator<String>>;
  metadata: <T = ContactMetadataSubscription>() => T;
}

export interface GovernmentBody {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GovernmentBodyPromise
  extends Promise<GovernmentBody>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  facilities: <T = FragmentableArray<GovernmentFacility>>(
    args?: {
      where?: GovernmentFacilityWhereInput;
      orderBy?: GovernmentFacilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  parent: <T = GovernmentBodyPromise>() => T;
  children: <T = FragmentableArray<GovernmentBody>>(
    args?: {
      where?: GovernmentBodyWhereInput;
      orderBy?: GovernmentBodyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  metadata: <T = GovernmentBodyMetadataPromise>() => T;
}

export interface GovernmentBodySubscription
  extends Promise<AsyncIterator<GovernmentBody>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  facilities: <T = Promise<AsyncIterator<GovernmentFacilitySubscription>>>(
    args?: {
      where?: GovernmentFacilityWhereInput;
      orderBy?: GovernmentFacilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  parent: <T = GovernmentBodySubscription>() => T;
  children: <T = Promise<AsyncIterator<GovernmentBodySubscription>>>(
    args?: {
      where?: GovernmentBodyWhereInput;
      orderBy?: GovernmentBodyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  metadata: <T = GovernmentBodyMetadataSubscription>() => T;
}

export interface GovernmentFacility {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name?: String;
  type: GovernmentFacilityType;
}

export interface GovernmentFacilityPromise
  extends Promise<GovernmentFacility>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  type: () => Promise<GovernmentFacilityType>;
  location: <T = LocationPromise>() => T;
  actors: <T = FragmentableArray<GovernmentActor>>(
    args?: {
      where?: GovernmentActorWhereInput;
      orderBy?: GovernmentActorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  phone: <T = PhoneNumberPromise>() => T;
  fax: <T = PhoneNumberPromise>() => T;
  email: <T = EmailAddressPromise>() => T;
  url: <T = ExternalLinkPromise>() => T;
  metadata: <T = FacilityMetadataPromise>() => T;
}

export interface GovernmentFacilitySubscription
  extends Promise<AsyncIterator<GovernmentFacility>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<GovernmentFacilityType>>;
  location: <T = LocationSubscription>() => T;
  actors: <T = Promise<AsyncIterator<GovernmentActorSubscription>>>(
    args?: {
      where?: GovernmentActorWhereInput;
      orderBy?: GovernmentActorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  phone: <T = PhoneNumberSubscription>() => T;
  fax: <T = PhoneNumberSubscription>() => T;
  email: <T = EmailAddressSubscription>() => T;
  url: <T = ExternalLinkSubscription>() => T;
  metadata: <T = FacilityMetadataSubscription>() => T;
}

export interface Location {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  formatted_address?: String;
  googleId?: String;
  placeId?: String;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  formatted_address: () => Promise<String>;
  googleId: () => Promise<String>;
  placeId: () => Promise<String>;
  location: <T = GeometryPromise>() => T;
  metadata: <T = LocationMetadataPromise>() => T;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  formatted_address: () => Promise<AsyncIterator<String>>;
  googleId: () => Promise<AsyncIterator<String>>;
  placeId: () => Promise<AsyncIterator<String>>;
  location: <T = GeometrySubscription>() => T;
  metadata: <T = LocationMetadataSubscription>() => T;
}

export interface Geometry {
  id: ID_Output;
  lat: Float;
  lng: Float;
}

export interface GeometryPromise extends Promise<Geometry>, Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
}

export interface GeometrySubscription
  extends Promise<AsyncIterator<Geometry>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
}

export interface LocationMetadata {
  id: ID_Output;
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface LocationMetadataPromise
  extends Promise<LocationMetadata>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isPrimary: () => Promise<Boolean>;
  isPublic: () => Promise<Boolean>;
  isVerified: () => Promise<Boolean>;
}

export interface LocationMetadataSubscription
  extends Promise<AsyncIterator<LocationMetadata>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isPrimary: () => Promise<AsyncIterator<Boolean>>;
  isPublic: () => Promise<AsyncIterator<Boolean>>;
  isVerified: () => Promise<AsyncIterator<Boolean>>;
}

export interface ExternalLink {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  payload: String;
}

export interface ExternalLinkPromise
  extends Promise<ExternalLink>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  payload: () => Promise<String>;
  metadata: <T = ContactMetadataPromise>() => T;
}

export interface ExternalLinkSubscription
  extends Promise<AsyncIterator<ExternalLink>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  payload: () => Promise<AsyncIterator<String>>;
  metadata: <T = ContactMetadataSubscription>() => T;
}

export interface FacilityMetadata {
  id: ID_Output;
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface FacilityMetadataPromise
  extends Promise<FacilityMetadata>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isPrimary: () => Promise<Boolean>;
  isPublic: () => Promise<Boolean>;
  isVerified: () => Promise<Boolean>;
}

export interface FacilityMetadataSubscription
  extends Promise<AsyncIterator<FacilityMetadata>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isPrimary: () => Promise<AsyncIterator<Boolean>>;
  isPublic: () => Promise<AsyncIterator<Boolean>>;
  isVerified: () => Promise<AsyncIterator<Boolean>>;
}

export interface GovernmentBodyMetadata {
  id: ID_Output;
  hasChildren?: Boolean;
  hasParent?: Boolean;
}

export interface GovernmentBodyMetadataPromise
  extends Promise<GovernmentBodyMetadata>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  hasChildren: () => Promise<Boolean>;
  hasParent: () => Promise<Boolean>;
}

export interface GovernmentBodyMetadataSubscription
  extends Promise<AsyncIterator<GovernmentBodyMetadata>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  hasChildren: () => Promise<AsyncIterator<Boolean>>;
  hasParent: () => Promise<AsyncIterator<Boolean>>;
}

export interface AffiliationRole {
  id: ID_Output;
  abbr?: String;
  name: String;
}

export interface AffiliationRolePromise
  extends Promise<AffiliationRole>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  body: <T = GovernmentBodyPromise>() => T;
  abbr: () => Promise<String>;
  name: () => Promise<String>;
}

export interface AffiliationRoleSubscription
  extends Promise<AsyncIterator<AffiliationRole>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  body: <T = GovernmentBodySubscription>() => T;
  abbr: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AffiliationConnection {
  pageInfo: PageInfo;
  edges: AffiliationEdge[];
}

export interface AffiliationConnectionPromise
  extends Promise<AffiliationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AffiliationEdge>>() => T;
  aggregate: <T = AggregateAffiliationPromise>() => T;
}

export interface AffiliationConnectionSubscription
  extends Promise<AsyncIterator<AffiliationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AffiliationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAffiliationSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AffiliationEdge {
  node: Affiliation;
  cursor: String;
}

export interface AffiliationEdgePromise
  extends Promise<AffiliationEdge>,
    Fragmentable {
  node: <T = AffiliationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AffiliationEdgeSubscription
  extends Promise<AsyncIterator<AffiliationEdge>>,
    Fragmentable {
  node: <T = AffiliationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAffiliation {
  count: Int;
}

export interface AggregateAffiliationPromise
  extends Promise<AggregateAffiliation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAffiliationSubscription
  extends Promise<AsyncIterator<AggregateAffiliation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AffiliationRoleConnection {
  pageInfo: PageInfo;
  edges: AffiliationRoleEdge[];
}

export interface AffiliationRoleConnectionPromise
  extends Promise<AffiliationRoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AffiliationRoleEdge>>() => T;
  aggregate: <T = AggregateAffiliationRolePromise>() => T;
}

export interface AffiliationRoleConnectionSubscription
  extends Promise<AsyncIterator<AffiliationRoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AffiliationRoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAffiliationRoleSubscription>() => T;
}

export interface AffiliationRoleEdge {
  node: AffiliationRole;
  cursor: String;
}

export interface AffiliationRoleEdgePromise
  extends Promise<AffiliationRoleEdge>,
    Fragmentable {
  node: <T = AffiliationRolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AffiliationRoleEdgeSubscription
  extends Promise<AsyncIterator<AffiliationRoleEdge>>,
    Fragmentable {
  node: <T = AffiliationRoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAffiliationRole {
  count: Int;
}

export interface AggregateAffiliationRolePromise
  extends Promise<AggregateAffiliationRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAffiliationRoleSubscription
  extends Promise<AsyncIterator<AggregateAffiliationRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactMetadataConnection {
  pageInfo: PageInfo;
  edges: ContactMetadataEdge[];
}

export interface ContactMetadataConnectionPromise
  extends Promise<ContactMetadataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactMetadataEdge>>() => T;
  aggregate: <T = AggregateContactMetadataPromise>() => T;
}

export interface ContactMetadataConnectionSubscription
  extends Promise<AsyncIterator<ContactMetadataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactMetadataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactMetadataSubscription>() => T;
}

export interface ContactMetadataEdge {
  node: ContactMetadata;
  cursor: String;
}

export interface ContactMetadataEdgePromise
  extends Promise<ContactMetadataEdge>,
    Fragmentable {
  node: <T = ContactMetadataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactMetadataEdgeSubscription
  extends Promise<AsyncIterator<ContactMetadataEdge>>,
    Fragmentable {
  node: <T = ContactMetadataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContactMetadata {
  count: Int;
}

export interface AggregateContactMetadataPromise
  extends Promise<AggregateContactMetadata>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactMetadataSubscription
  extends Promise<AsyncIterator<AggregateContactMetadata>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmailAddressConnection {
  pageInfo: PageInfo;
  edges: EmailAddressEdge[];
}

export interface EmailAddressConnectionPromise
  extends Promise<EmailAddressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmailAddressEdge>>() => T;
  aggregate: <T = AggregateEmailAddressPromise>() => T;
}

export interface EmailAddressConnectionSubscription
  extends Promise<AsyncIterator<EmailAddressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmailAddressEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmailAddressSubscription>() => T;
}

export interface EmailAddressEdge {
  node: EmailAddress;
  cursor: String;
}

export interface EmailAddressEdgePromise
  extends Promise<EmailAddressEdge>,
    Fragmentable {
  node: <T = EmailAddressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmailAddressEdgeSubscription
  extends Promise<AsyncIterator<EmailAddressEdge>>,
    Fragmentable {
  node: <T = EmailAddressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmailAddress {
  count: Int;
}

export interface AggregateEmailAddressPromise
  extends Promise<AggregateEmailAddress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmailAddressSubscription
  extends Promise<AsyncIterator<AggregateEmailAddress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExternalLinkConnection {
  pageInfo: PageInfo;
  edges: ExternalLinkEdge[];
}

export interface ExternalLinkConnectionPromise
  extends Promise<ExternalLinkConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExternalLinkEdge>>() => T;
  aggregate: <T = AggregateExternalLinkPromise>() => T;
}

export interface ExternalLinkConnectionSubscription
  extends Promise<AsyncIterator<ExternalLinkConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExternalLinkEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExternalLinkSubscription>() => T;
}

export interface ExternalLinkEdge {
  node: ExternalLink;
  cursor: String;
}

export interface ExternalLinkEdgePromise
  extends Promise<ExternalLinkEdge>,
    Fragmentable {
  node: <T = ExternalLinkPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExternalLinkEdgeSubscription
  extends Promise<AsyncIterator<ExternalLinkEdge>>,
    Fragmentable {
  node: <T = ExternalLinkSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExternalLink {
  count: Int;
}

export interface AggregateExternalLinkPromise
  extends Promise<AggregateExternalLink>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExternalLinkSubscription
  extends Promise<AsyncIterator<AggregateExternalLink>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FacilityMetadataConnection {
  pageInfo: PageInfo;
  edges: FacilityMetadataEdge[];
}

export interface FacilityMetadataConnectionPromise
  extends Promise<FacilityMetadataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FacilityMetadataEdge>>() => T;
  aggregate: <T = AggregateFacilityMetadataPromise>() => T;
}

export interface FacilityMetadataConnectionSubscription
  extends Promise<AsyncIterator<FacilityMetadataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FacilityMetadataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFacilityMetadataSubscription>() => T;
}

export interface FacilityMetadataEdge {
  node: FacilityMetadata;
  cursor: String;
}

export interface FacilityMetadataEdgePromise
  extends Promise<FacilityMetadataEdge>,
    Fragmentable {
  node: <T = FacilityMetadataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FacilityMetadataEdgeSubscription
  extends Promise<AsyncIterator<FacilityMetadataEdge>>,
    Fragmentable {
  node: <T = FacilityMetadataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFacilityMetadata {
  count: Int;
}

export interface AggregateFacilityMetadataPromise
  extends Promise<AggregateFacilityMetadata>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFacilityMetadataSubscription
  extends Promise<AsyncIterator<AggregateFacilityMetadata>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GeometryConnection {
  pageInfo: PageInfo;
  edges: GeometryEdge[];
}

export interface GeometryConnectionPromise
  extends Promise<GeometryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GeometryEdge>>() => T;
  aggregate: <T = AggregateGeometryPromise>() => T;
}

export interface GeometryConnectionSubscription
  extends Promise<AsyncIterator<GeometryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GeometryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGeometrySubscription>() => T;
}

export interface GeometryEdge {
  node: Geometry;
  cursor: String;
}

export interface GeometryEdgePromise
  extends Promise<GeometryEdge>,
    Fragmentable {
  node: <T = GeometryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GeometryEdgeSubscription
  extends Promise<AsyncIterator<GeometryEdge>>,
    Fragmentable {
  node: <T = GeometrySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGeometry {
  count: Int;
}

export interface AggregateGeometryPromise
  extends Promise<AggregateGeometry>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGeometrySubscription
  extends Promise<AsyncIterator<AggregateGeometry>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GovernmentActorConnection {
  pageInfo: PageInfo;
  edges: GovernmentActorEdge[];
}

export interface GovernmentActorConnectionPromise
  extends Promise<GovernmentActorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GovernmentActorEdge>>() => T;
  aggregate: <T = AggregateGovernmentActorPromise>() => T;
}

export interface GovernmentActorConnectionSubscription
  extends Promise<AsyncIterator<GovernmentActorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GovernmentActorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGovernmentActorSubscription>() => T;
}

export interface GovernmentActorEdge {
  node: GovernmentActor;
  cursor: String;
}

export interface GovernmentActorEdgePromise
  extends Promise<GovernmentActorEdge>,
    Fragmentable {
  node: <T = GovernmentActorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GovernmentActorEdgeSubscription
  extends Promise<AsyncIterator<GovernmentActorEdge>>,
    Fragmentable {
  node: <T = GovernmentActorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGovernmentActor {
  count: Int;
}

export interface AggregateGovernmentActorPromise
  extends Promise<AggregateGovernmentActor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGovernmentActorSubscription
  extends Promise<AsyncIterator<AggregateGovernmentActor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GovernmentActorProfileConnection {
  pageInfo: PageInfo;
  edges: GovernmentActorProfileEdge[];
}

export interface GovernmentActorProfileConnectionPromise
  extends Promise<GovernmentActorProfileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GovernmentActorProfileEdge>>() => T;
  aggregate: <T = AggregateGovernmentActorProfilePromise>() => T;
}

export interface GovernmentActorProfileConnectionSubscription
  extends Promise<AsyncIterator<GovernmentActorProfileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<GovernmentActorProfileEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateGovernmentActorProfileSubscription>() => T;
}

export interface GovernmentActorProfileEdge {
  node: GovernmentActorProfile;
  cursor: String;
}

export interface GovernmentActorProfileEdgePromise
  extends Promise<GovernmentActorProfileEdge>,
    Fragmentable {
  node: <T = GovernmentActorProfilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GovernmentActorProfileEdgeSubscription
  extends Promise<AsyncIterator<GovernmentActorProfileEdge>>,
    Fragmentable {
  node: <T = GovernmentActorProfileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGovernmentActorProfile {
  count: Int;
}

export interface AggregateGovernmentActorProfilePromise
  extends Promise<AggregateGovernmentActorProfile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGovernmentActorProfileSubscription
  extends Promise<AsyncIterator<AggregateGovernmentActorProfile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GovernmentBodyConnection {
  pageInfo: PageInfo;
  edges: GovernmentBodyEdge[];
}

export interface GovernmentBodyConnectionPromise
  extends Promise<GovernmentBodyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GovernmentBodyEdge>>() => T;
  aggregate: <T = AggregateGovernmentBodyPromise>() => T;
}

export interface GovernmentBodyConnectionSubscription
  extends Promise<AsyncIterator<GovernmentBodyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GovernmentBodyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGovernmentBodySubscription>() => T;
}

export interface GovernmentBodyEdge {
  node: GovernmentBody;
  cursor: String;
}

export interface GovernmentBodyEdgePromise
  extends Promise<GovernmentBodyEdge>,
    Fragmentable {
  node: <T = GovernmentBodyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GovernmentBodyEdgeSubscription
  extends Promise<AsyncIterator<GovernmentBodyEdge>>,
    Fragmentable {
  node: <T = GovernmentBodySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGovernmentBody {
  count: Int;
}

export interface AggregateGovernmentBodyPromise
  extends Promise<AggregateGovernmentBody>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGovernmentBodySubscription
  extends Promise<AsyncIterator<AggregateGovernmentBody>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GovernmentBodyMetadataConnection {
  pageInfo: PageInfo;
  edges: GovernmentBodyMetadataEdge[];
}

export interface GovernmentBodyMetadataConnectionPromise
  extends Promise<GovernmentBodyMetadataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GovernmentBodyMetadataEdge>>() => T;
  aggregate: <T = AggregateGovernmentBodyMetadataPromise>() => T;
}

export interface GovernmentBodyMetadataConnectionSubscription
  extends Promise<AsyncIterator<GovernmentBodyMetadataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<GovernmentBodyMetadataEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateGovernmentBodyMetadataSubscription>() => T;
}

export interface GovernmentBodyMetadataEdge {
  node: GovernmentBodyMetadata;
  cursor: String;
}

export interface GovernmentBodyMetadataEdgePromise
  extends Promise<GovernmentBodyMetadataEdge>,
    Fragmentable {
  node: <T = GovernmentBodyMetadataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GovernmentBodyMetadataEdgeSubscription
  extends Promise<AsyncIterator<GovernmentBodyMetadataEdge>>,
    Fragmentable {
  node: <T = GovernmentBodyMetadataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGovernmentBodyMetadata {
  count: Int;
}

export interface AggregateGovernmentBodyMetadataPromise
  extends Promise<AggregateGovernmentBodyMetadata>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGovernmentBodyMetadataSubscription
  extends Promise<AsyncIterator<AggregateGovernmentBodyMetadata>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GovernmentFacilityConnection {
  pageInfo: PageInfo;
  edges: GovernmentFacilityEdge[];
}

export interface GovernmentFacilityConnectionPromise
  extends Promise<GovernmentFacilityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GovernmentFacilityEdge>>() => T;
  aggregate: <T = AggregateGovernmentFacilityPromise>() => T;
}

export interface GovernmentFacilityConnectionSubscription
  extends Promise<AsyncIterator<GovernmentFacilityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<GovernmentFacilityEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateGovernmentFacilitySubscription>() => T;
}

export interface GovernmentFacilityEdge {
  node: GovernmentFacility;
  cursor: String;
}

export interface GovernmentFacilityEdgePromise
  extends Promise<GovernmentFacilityEdge>,
    Fragmentable {
  node: <T = GovernmentFacilityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GovernmentFacilityEdgeSubscription
  extends Promise<AsyncIterator<GovernmentFacilityEdge>>,
    Fragmentable {
  node: <T = GovernmentFacilitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGovernmentFacility {
  count: Int;
}

export interface AggregateGovernmentFacilityPromise
  extends Promise<AggregateGovernmentFacility>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGovernmentFacilitySubscription
  extends Promise<AsyncIterator<AggregateGovernmentFacility>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationConnection {
  pageInfo: PageInfo;
  edges: LocationEdge[];
}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface LocationEdge {
  node: Location;
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationMetadataConnection {
  pageInfo: PageInfo;
  edges: LocationMetadataEdge[];
}

export interface LocationMetadataConnectionPromise
  extends Promise<LocationMetadataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationMetadataEdge>>() => T;
  aggregate: <T = AggregateLocationMetadataPromise>() => T;
}

export interface LocationMetadataConnectionSubscription
  extends Promise<AsyncIterator<LocationMetadataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationMetadataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationMetadataSubscription>() => T;
}

export interface LocationMetadataEdge {
  node: LocationMetadata;
  cursor: String;
}

export interface LocationMetadataEdgePromise
  extends Promise<LocationMetadataEdge>,
    Fragmentable {
  node: <T = LocationMetadataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationMetadataEdgeSubscription
  extends Promise<AsyncIterator<LocationMetadataEdge>>,
    Fragmentable {
  node: <T = LocationMetadataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLocationMetadata {
  count: Int;
}

export interface AggregateLocationMetadataPromise
  extends Promise<AggregateLocationMetadata>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationMetadataSubscription
  extends Promise<AsyncIterator<AggregateLocationMetadata>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PhoneNumberConnection {
  pageInfo: PageInfo;
  edges: PhoneNumberEdge[];
}

export interface PhoneNumberConnectionPromise
  extends Promise<PhoneNumberConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhoneNumberEdge>>() => T;
  aggregate: <T = AggregatePhoneNumberPromise>() => T;
}

export interface PhoneNumberConnectionSubscription
  extends Promise<AsyncIterator<PhoneNumberConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PhoneNumberEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePhoneNumberSubscription>() => T;
}

export interface PhoneNumberEdge {
  node: PhoneNumber;
  cursor: String;
}

export interface PhoneNumberEdgePromise
  extends Promise<PhoneNumberEdge>,
    Fragmentable {
  node: <T = PhoneNumberPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhoneNumberEdgeSubscription
  extends Promise<AsyncIterator<PhoneNumberEdge>>,
    Fragmentable {
  node: <T = PhoneNumberSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePhoneNumber {
  count: Int;
}

export interface AggregatePhoneNumberPromise
  extends Promise<AggregatePhoneNumber>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhoneNumberSubscription
  extends Promise<AsyncIterator<AggregatePhoneNumber>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  handle?: String;
  cognitoId: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  handle: () => Promise<String>;
  cognitoId: () => Promise<String>;
  profile: <T = UserProfilePromise>() => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  handle: () => Promise<AsyncIterator<String>>;
  cognitoId: () => Promise<AsyncIterator<String>>;
  profile: <T = UserProfileSubscription>() => T;
}

export interface UserProfile {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName?: String;
  lastName?: String;
  avatar?: String;
  location?: String;
}

export interface UserProfilePromise extends Promise<UserProfile>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  avatar: () => Promise<String>;
  location: () => Promise<String>;
  email: <T = FragmentableArray<EmailAddress>>(
    args?: {
      where?: EmailAddressWhereInput;
      orderBy?: EmailAddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  phone_number: <T = FragmentableArray<PhoneNumber>>(
    args?: {
      where?: PhoneNumberWhereInput;
      orderBy?: PhoneNumberOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserProfileSubscription
  extends Promise<AsyncIterator<UserProfile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  email: <T = Promise<AsyncIterator<EmailAddressSubscription>>>(
    args?: {
      where?: EmailAddressWhereInput;
      orderBy?: EmailAddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  phone_number: <T = Promise<AsyncIterator<PhoneNumberSubscription>>>(
    args?: {
      where?: PhoneNumberWhereInput;
      orderBy?: PhoneNumberOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserProfileConnection {
  pageInfo: PageInfo;
  edges: UserProfileEdge[];
}

export interface UserProfileConnectionPromise
  extends Promise<UserProfileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserProfileEdge>>() => T;
  aggregate: <T = AggregateUserProfilePromise>() => T;
}

export interface UserProfileConnectionSubscription
  extends Promise<AsyncIterator<UserProfileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserProfileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserProfileSubscription>() => T;
}

export interface UserProfileEdge {
  node: UserProfile;
  cursor: String;
}

export interface UserProfileEdgePromise
  extends Promise<UserProfileEdge>,
    Fragmentable {
  node: <T = UserProfilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserProfileEdgeSubscription
  extends Promise<AsyncIterator<UserProfileEdge>>,
    Fragmentable {
  node: <T = UserProfileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserProfile {
  count: Int;
}

export interface AggregateUserProfilePromise
  extends Promise<AggregateUserProfile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserProfileSubscription
  extends Promise<AsyncIterator<AggregateUserProfile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AffiliationSubscriptionPayload {
  mutation: MutationType;
  node: Affiliation;
  updatedFields: String[];
  previousValues: AffiliationPreviousValues;
}

export interface AffiliationSubscriptionPayloadPromise
  extends Promise<AffiliationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AffiliationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AffiliationPreviousValuesPromise>() => T;
}

export interface AffiliationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AffiliationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AffiliationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AffiliationPreviousValuesSubscription>() => T;
}

export interface AffiliationPreviousValues {
  id: ID_Output;
  dateStarted: DateTimeOutput;
  dateEnded?: DateTimeOutput;
  notes?: Json;
}

export interface AffiliationPreviousValuesPromise
  extends Promise<AffiliationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateStarted: () => Promise<DateTimeOutput>;
  dateEnded: () => Promise<DateTimeOutput>;
  notes: () => Promise<Json>;
}

export interface AffiliationPreviousValuesSubscription
  extends Promise<AsyncIterator<AffiliationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateStarted: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateEnded: () => Promise<AsyncIterator<DateTimeOutput>>;
  notes: () => Promise<AsyncIterator<Json>>;
}

export interface AffiliationRoleSubscriptionPayload {
  mutation: MutationType;
  node: AffiliationRole;
  updatedFields: String[];
  previousValues: AffiliationRolePreviousValues;
}

export interface AffiliationRoleSubscriptionPayloadPromise
  extends Promise<AffiliationRoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AffiliationRolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AffiliationRolePreviousValuesPromise>() => T;
}

export interface AffiliationRoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AffiliationRoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AffiliationRoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AffiliationRolePreviousValuesSubscription>() => T;
}

export interface AffiliationRolePreviousValues {
  id: ID_Output;
  abbr?: String;
  name: String;
}

export interface AffiliationRolePreviousValuesPromise
  extends Promise<AffiliationRolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  abbr: () => Promise<String>;
  name: () => Promise<String>;
}

export interface AffiliationRolePreviousValuesSubscription
  extends Promise<AsyncIterator<AffiliationRolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  abbr: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ContactMetadataSubscriptionPayload {
  mutation: MutationType;
  node: ContactMetadata;
  updatedFields: String[];
  previousValues: ContactMetadataPreviousValues;
}

export interface ContactMetadataSubscriptionPayloadPromise
  extends Promise<ContactMetadataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactMetadataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactMetadataPreviousValuesPromise>() => T;
}

export interface ContactMetadataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactMetadataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactMetadataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactMetadataPreviousValuesSubscription>() => T;
}

export interface ContactMetadataPreviousValues {
  id: ID_Output;
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface ContactMetadataPreviousValuesPromise
  extends Promise<ContactMetadataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isPrimary: () => Promise<Boolean>;
  isPublic: () => Promise<Boolean>;
  isVerified: () => Promise<Boolean>;
}

export interface ContactMetadataPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactMetadataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isPrimary: () => Promise<AsyncIterator<Boolean>>;
  isPublic: () => Promise<AsyncIterator<Boolean>>;
  isVerified: () => Promise<AsyncIterator<Boolean>>;
}

export interface EmailAddressSubscriptionPayload {
  mutation: MutationType;
  node: EmailAddress;
  updatedFields: String[];
  previousValues: EmailAddressPreviousValues;
}

export interface EmailAddressSubscriptionPayloadPromise
  extends Promise<EmailAddressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmailAddressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmailAddressPreviousValuesPromise>() => T;
}

export interface EmailAddressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmailAddressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmailAddressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmailAddressPreviousValuesSubscription>() => T;
}

export interface EmailAddressPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  payload: String;
}

export interface EmailAddressPreviousValuesPromise
  extends Promise<EmailAddressPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  payload: () => Promise<String>;
}

export interface EmailAddressPreviousValuesSubscription
  extends Promise<AsyncIterator<EmailAddressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  payload: () => Promise<AsyncIterator<String>>;
}

export interface ExternalLinkSubscriptionPayload {
  mutation: MutationType;
  node: ExternalLink;
  updatedFields: String[];
  previousValues: ExternalLinkPreviousValues;
}

export interface ExternalLinkSubscriptionPayloadPromise
  extends Promise<ExternalLinkSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExternalLinkPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExternalLinkPreviousValuesPromise>() => T;
}

export interface ExternalLinkSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExternalLinkSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExternalLinkSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExternalLinkPreviousValuesSubscription>() => T;
}

export interface ExternalLinkPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  payload: String;
}

export interface ExternalLinkPreviousValuesPromise
  extends Promise<ExternalLinkPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  payload: () => Promise<String>;
}

export interface ExternalLinkPreviousValuesSubscription
  extends Promise<AsyncIterator<ExternalLinkPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  payload: () => Promise<AsyncIterator<String>>;
}

export interface FacilityMetadataSubscriptionPayload {
  mutation: MutationType;
  node: FacilityMetadata;
  updatedFields: String[];
  previousValues: FacilityMetadataPreviousValues;
}

export interface FacilityMetadataSubscriptionPayloadPromise
  extends Promise<FacilityMetadataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FacilityMetadataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FacilityMetadataPreviousValuesPromise>() => T;
}

export interface FacilityMetadataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FacilityMetadataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FacilityMetadataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FacilityMetadataPreviousValuesSubscription>() => T;
}

export interface FacilityMetadataPreviousValues {
  id: ID_Output;
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface FacilityMetadataPreviousValuesPromise
  extends Promise<FacilityMetadataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isPrimary: () => Promise<Boolean>;
  isPublic: () => Promise<Boolean>;
  isVerified: () => Promise<Boolean>;
}

export interface FacilityMetadataPreviousValuesSubscription
  extends Promise<AsyncIterator<FacilityMetadataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isPrimary: () => Promise<AsyncIterator<Boolean>>;
  isPublic: () => Promise<AsyncIterator<Boolean>>;
  isVerified: () => Promise<AsyncIterator<Boolean>>;
}

export interface GeometrySubscriptionPayload {
  mutation: MutationType;
  node: Geometry;
  updatedFields: String[];
  previousValues: GeometryPreviousValues;
}

export interface GeometrySubscriptionPayloadPromise
  extends Promise<GeometrySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GeometryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GeometryPreviousValuesPromise>() => T;
}

export interface GeometrySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GeometrySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GeometrySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GeometryPreviousValuesSubscription>() => T;
}

export interface GeometryPreviousValues {
  id: ID_Output;
  lat: Float;
  lng: Float;
}

export interface GeometryPreviousValuesPromise
  extends Promise<GeometryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
}

export interface GeometryPreviousValuesSubscription
  extends Promise<AsyncIterator<GeometryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
}

export interface GovernmentActorSubscriptionPayload {
  mutation: MutationType;
  node: GovernmentActor;
  updatedFields: String[];
  previousValues: GovernmentActorPreviousValues;
}

export interface GovernmentActorSubscriptionPayloadPromise
  extends Promise<GovernmentActorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GovernmentActorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GovernmentActorPreviousValuesPromise>() => T;
}

export interface GovernmentActorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GovernmentActorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GovernmentActorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GovernmentActorPreviousValuesSubscription>() => T;
}

export interface GovernmentActorPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GovernmentActorPreviousValuesPromise
  extends Promise<GovernmentActorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GovernmentActorPreviousValuesSubscription
  extends Promise<AsyncIterator<GovernmentActorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GovernmentActorProfileSubscriptionPayload {
  mutation: MutationType;
  node: GovernmentActorProfile;
  updatedFields: String[];
  previousValues: GovernmentActorProfilePreviousValues;
}

export interface GovernmentActorProfileSubscriptionPayloadPromise
  extends Promise<GovernmentActorProfileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GovernmentActorProfilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GovernmentActorProfilePreviousValuesPromise>() => T;
}

export interface GovernmentActorProfileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GovernmentActorProfileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GovernmentActorProfileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GovernmentActorProfilePreviousValuesSubscription>() => T;
}

export interface GovernmentActorProfilePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName?: String;
  lastName?: String;
}

export interface GovernmentActorProfilePreviousValuesPromise
  extends Promise<GovernmentActorProfilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
}

export interface GovernmentActorProfilePreviousValuesSubscription
  extends Promise<AsyncIterator<GovernmentActorProfilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
}

export interface GovernmentBodySubscriptionPayload {
  mutation: MutationType;
  node: GovernmentBody;
  updatedFields: String[];
  previousValues: GovernmentBodyPreviousValues;
}

export interface GovernmentBodySubscriptionPayloadPromise
  extends Promise<GovernmentBodySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GovernmentBodyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GovernmentBodyPreviousValuesPromise>() => T;
}

export interface GovernmentBodySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GovernmentBodySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GovernmentBodySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GovernmentBodyPreviousValuesSubscription>() => T;
}

export interface GovernmentBodyPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GovernmentBodyPreviousValuesPromise
  extends Promise<GovernmentBodyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GovernmentBodyPreviousValuesSubscription
  extends Promise<AsyncIterator<GovernmentBodyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GovernmentBodyMetadataSubscriptionPayload {
  mutation: MutationType;
  node: GovernmentBodyMetadata;
  updatedFields: String[];
  previousValues: GovernmentBodyMetadataPreviousValues;
}

export interface GovernmentBodyMetadataSubscriptionPayloadPromise
  extends Promise<GovernmentBodyMetadataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GovernmentBodyMetadataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GovernmentBodyMetadataPreviousValuesPromise>() => T;
}

export interface GovernmentBodyMetadataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GovernmentBodyMetadataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GovernmentBodyMetadataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GovernmentBodyMetadataPreviousValuesSubscription>() => T;
}

export interface GovernmentBodyMetadataPreviousValues {
  id: ID_Output;
  hasChildren?: Boolean;
  hasParent?: Boolean;
}

export interface GovernmentBodyMetadataPreviousValuesPromise
  extends Promise<GovernmentBodyMetadataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  hasChildren: () => Promise<Boolean>;
  hasParent: () => Promise<Boolean>;
}

export interface GovernmentBodyMetadataPreviousValuesSubscription
  extends Promise<AsyncIterator<GovernmentBodyMetadataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  hasChildren: () => Promise<AsyncIterator<Boolean>>;
  hasParent: () => Promise<AsyncIterator<Boolean>>;
}

export interface GovernmentFacilitySubscriptionPayload {
  mutation: MutationType;
  node: GovernmentFacility;
  updatedFields: String[];
  previousValues: GovernmentFacilityPreviousValues;
}

export interface GovernmentFacilitySubscriptionPayloadPromise
  extends Promise<GovernmentFacilitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GovernmentFacilityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GovernmentFacilityPreviousValuesPromise>() => T;
}

export interface GovernmentFacilitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GovernmentFacilitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GovernmentFacilitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GovernmentFacilityPreviousValuesSubscription>() => T;
}

export interface GovernmentFacilityPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name?: String;
  type: GovernmentFacilityType;
}

export interface GovernmentFacilityPreviousValuesPromise
  extends Promise<GovernmentFacilityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  type: () => Promise<GovernmentFacilityType>;
}

export interface GovernmentFacilityPreviousValuesSubscription
  extends Promise<AsyncIterator<GovernmentFacilityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<GovernmentFacilityType>>;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  node: Location;
  updatedFields: String[];
  previousValues: LocationPreviousValues;
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface LocationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  formatted_address?: String;
  googleId?: String;
  placeId?: String;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  formatted_address: () => Promise<String>;
  googleId: () => Promise<String>;
  placeId: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  formatted_address: () => Promise<AsyncIterator<String>>;
  googleId: () => Promise<AsyncIterator<String>>;
  placeId: () => Promise<AsyncIterator<String>>;
}

export interface LocationMetadataSubscriptionPayload {
  mutation: MutationType;
  node: LocationMetadata;
  updatedFields: String[];
  previousValues: LocationMetadataPreviousValues;
}

export interface LocationMetadataSubscriptionPayloadPromise
  extends Promise<LocationMetadataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationMetadataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationMetadataPreviousValuesPromise>() => T;
}

export interface LocationMetadataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationMetadataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationMetadataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationMetadataPreviousValuesSubscription>() => T;
}

export interface LocationMetadataPreviousValues {
  id: ID_Output;
  isPrimary?: Boolean;
  isPublic?: Boolean;
  isVerified?: Boolean;
}

export interface LocationMetadataPreviousValuesPromise
  extends Promise<LocationMetadataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isPrimary: () => Promise<Boolean>;
  isPublic: () => Promise<Boolean>;
  isVerified: () => Promise<Boolean>;
}

export interface LocationMetadataPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationMetadataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isPrimary: () => Promise<AsyncIterator<Boolean>>;
  isPublic: () => Promise<AsyncIterator<Boolean>>;
  isVerified: () => Promise<AsyncIterator<Boolean>>;
}

export interface PhoneNumberSubscriptionPayload {
  mutation: MutationType;
  node: PhoneNumber;
  updatedFields: String[];
  previousValues: PhoneNumberPreviousValues;
}

export interface PhoneNumberSubscriptionPayloadPromise
  extends Promise<PhoneNumberSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhoneNumberPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PhoneNumberPreviousValuesPromise>() => T;
}

export interface PhoneNumberSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PhoneNumberSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhoneNumberSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PhoneNumberPreviousValuesSubscription>() => T;
}

export interface PhoneNumberPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  payload: String;
}

export interface PhoneNumberPreviousValuesPromise
  extends Promise<PhoneNumberPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  payload: () => Promise<String>;
}

export interface PhoneNumberPreviousValuesSubscription
  extends Promise<AsyncIterator<PhoneNumberPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  payload: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  handle?: String;
  cognitoId: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  handle: () => Promise<String>;
  cognitoId: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  handle: () => Promise<AsyncIterator<String>>;
  cognitoId: () => Promise<AsyncIterator<String>>;
}

export interface UserProfileSubscriptionPayload {
  mutation: MutationType;
  node: UserProfile;
  updatedFields: String[];
  previousValues: UserProfilePreviousValues;
}

export interface UserProfileSubscriptionPayloadPromise
  extends Promise<UserProfileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserProfilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserProfilePreviousValuesPromise>() => T;
}

export interface UserProfileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserProfileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserProfileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserProfilePreviousValuesSubscription>() => T;
}

export interface UserProfilePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName?: String;
  lastName?: String;
  avatar?: String;
  location?: String;
}

export interface UserProfilePreviousValuesPromise
  extends Promise<UserProfilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  avatar: () => Promise<String>;
  location: () => Promise<String>;
}

export interface UserProfilePreviousValuesSubscription
  extends Promise<AsyncIterator<UserProfilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Json = any;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "EmailAddress",
    embedded: false
  },
  {
    name: "PhoneNumber",
    embedded: false
  },
  {
    name: "ExternalLink",
    embedded: false
  },
  {
    name: "ContactMetadata",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "LocationMetadata",
    embedded: false
  },
  {
    name: "Geometry",
    embedded: false
  },
  {
    name: "GovernmentFacility",
    embedded: false
  },
  {
    name: "GovernmentFacilityType",
    embedded: false
  },
  {
    name: "FacilityMetadata",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserProfile",
    embedded: false
  },
  {
    name: "GovernmentBody",
    embedded: false
  },
  {
    name: "GovernmentActor",
    embedded: false
  },
  {
    name: "GovernmentActorProfile",
    embedded: false
  },
  {
    name: "GovernmentBodyMetadata",
    embedded: false
  },
  {
    name: "Affiliation",
    embedded: false
  },
  {
    name: "AffiliationRole",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
