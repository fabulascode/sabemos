### This file was autogenerated by Nexus 0.11.7
### Do not make changes to this file directly


type Affiliation {
  actor: GovernmentActor!
  body: GovernmentBody!
  dateEnded: DateTime
  dateStarted: DateTime!
  id: ID!
  notes: Json
  role: AffiliationRole
}

type AffiliationConnection {
  aggregate: AggregateAffiliation!
  edges: [AffiliationEdge!]!
  pageInfo: PageInfo!
}

input AffiliationCreateInput {
  actor: GovernmentActorCreateOneWithoutAffiliationsInput!
  body: GovernmentBodyCreateOneInput!
  dateEnded: DateTime
  dateStarted: DateTime!
  id: ID
  notes: Json
  role: AffiliationRoleCreateOneInput
}

input AffiliationCreateManyWithoutActorInput {
  connect: [AffiliationWhereUniqueInput!]
  create: [AffiliationCreateWithoutActorInput!]
}

input AffiliationCreateWithoutActorInput {
  body: GovernmentBodyCreateOneInput!
  dateEnded: DateTime
  dateStarted: DateTime!
  id: ID
  notes: Json
  role: AffiliationRoleCreateOneInput
}

type AffiliationEdge {
  cursor: String!
  node: Affiliation!
}

enum AffiliationOrderByInput {
  createdAt_ASC
  createdAt_DESC
  dateEnded_ASC
  dateEnded_DESC
  dateStarted_ASC
  dateStarted_DESC
  id_ASC
  id_DESC
  notes_ASC
  notes_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AffiliationRole {
  abbr: String
  body: GovernmentBody!
  id: ID!
  name: String!
}

type AffiliationRoleConnection {
  aggregate: AggregateAffiliationRole!
  edges: [AffiliationRoleEdge!]!
  pageInfo: PageInfo!
}

input AffiliationRoleCreateInput {
  abbr: String
  body: GovernmentBodyCreateOneInput!
  id: ID
  name: String!
}

input AffiliationRoleCreateOneInput {
  connect: AffiliationRoleWhereUniqueInput
  create: AffiliationRoleCreateInput
}

type AffiliationRoleEdge {
  cursor: String!
  node: AffiliationRole!
}

enum AffiliationRoleOrderByInput {
  abbr_ASC
  abbr_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input AffiliationRoleUpdateDataInput {
  abbr: String
  body: GovernmentBodyUpdateOneRequiredInput
  name: String
}

input AffiliationRoleUpdateInput {
  abbr: String
  body: GovernmentBodyUpdateOneRequiredInput
  name: String
}

input AffiliationRoleUpdateManyMutationInput {
  abbr: String
  name: String
}

input AffiliationRoleUpdateOneInput {
  connect: AffiliationRoleWhereUniqueInput
  create: AffiliationRoleCreateInput
  delete: Boolean
  disconnect: Boolean
  update: AffiliationRoleUpdateDataInput
  upsert: AffiliationRoleUpsertNestedInput
}

input AffiliationRoleUpsertNestedInput {
  create: AffiliationRoleCreateInput!
  update: AffiliationRoleUpdateDataInput!
}

input AffiliationRoleWhereInput {
  abbr: String
  abbr_contains: String
  abbr_ends_with: String
  abbr_gt: String
  abbr_gte: String
  abbr_in: [String!]
  abbr_lt: String
  abbr_lte: String
  abbr_not: String
  abbr_not_contains: String
  abbr_not_ends_with: String
  abbr_not_in: [String!]
  abbr_not_starts_with: String
  abbr_starts_with: String
  AND: [AffiliationRoleWhereInput!]
  body: GovernmentBodyWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [AffiliationRoleWhereInput!]
  OR: [AffiliationRoleWhereInput!]
}

input AffiliationRoleWhereUniqueInput {
  id: ID
}

input AffiliationScalarWhereInput {
  AND: [AffiliationScalarWhereInput!]
  dateEnded: DateTime
  dateEnded_gt: DateTime
  dateEnded_gte: DateTime
  dateEnded_in: [DateTime!]
  dateEnded_lt: DateTime
  dateEnded_lte: DateTime
  dateEnded_not: DateTime
  dateEnded_not_in: [DateTime!]
  dateStarted: DateTime
  dateStarted_gt: DateTime
  dateStarted_gte: DateTime
  dateStarted_in: [DateTime!]
  dateStarted_lt: DateTime
  dateStarted_lte: DateTime
  dateStarted_not: DateTime
  dateStarted_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [AffiliationScalarWhereInput!]
  OR: [AffiliationScalarWhereInput!]
}

input AffiliationUpdateInput {
  actor: GovernmentActorUpdateOneRequiredWithoutAffiliationsInput
  body: GovernmentBodyUpdateOneRequiredInput
  dateEnded: DateTime
  dateStarted: DateTime
  notes: Json
  role: AffiliationRoleUpdateOneInput
}

input AffiliationUpdateManyDataInput {
  dateEnded: DateTime
  dateStarted: DateTime
  notes: Json
}

input AffiliationUpdateManyMutationInput {
  dateEnded: DateTime
  dateStarted: DateTime
  notes: Json
}

input AffiliationUpdateManyWithoutActorInput {
  connect: [AffiliationWhereUniqueInput!]
  create: [AffiliationCreateWithoutActorInput!]
  delete: [AffiliationWhereUniqueInput!]
  deleteMany: [AffiliationScalarWhereInput!]
  disconnect: [AffiliationWhereUniqueInput!]
  set: [AffiliationWhereUniqueInput!]
  update: [AffiliationUpdateWithWhereUniqueWithoutActorInput!]
  updateMany: [AffiliationUpdateManyWithWhereNestedInput!]
  upsert: [AffiliationUpsertWithWhereUniqueWithoutActorInput!]
}

input AffiliationUpdateManyWithWhereNestedInput {
  data: AffiliationUpdateManyDataInput!
  where: AffiliationScalarWhereInput!
}

input AffiliationUpdateWithoutActorDataInput {
  body: GovernmentBodyUpdateOneRequiredInput
  dateEnded: DateTime
  dateStarted: DateTime
  notes: Json
  role: AffiliationRoleUpdateOneInput
}

input AffiliationUpdateWithWhereUniqueWithoutActorInput {
  data: AffiliationUpdateWithoutActorDataInput!
  where: AffiliationWhereUniqueInput!
}

input AffiliationUpsertWithWhereUniqueWithoutActorInput {
  create: AffiliationCreateWithoutActorInput!
  update: AffiliationUpdateWithoutActorDataInput!
  where: AffiliationWhereUniqueInput!
}

input AffiliationWhereInput {
  actor: GovernmentActorWhereInput
  AND: [AffiliationWhereInput!]
  body: GovernmentBodyWhereInput
  dateEnded: DateTime
  dateEnded_gt: DateTime
  dateEnded_gte: DateTime
  dateEnded_in: [DateTime!]
  dateEnded_lt: DateTime
  dateEnded_lte: DateTime
  dateEnded_not: DateTime
  dateEnded_not_in: [DateTime!]
  dateStarted: DateTime
  dateStarted_gt: DateTime
  dateStarted_gte: DateTime
  dateStarted_in: [DateTime!]
  dateStarted_lt: DateTime
  dateStarted_lte: DateTime
  dateStarted_not: DateTime
  dateStarted_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [AffiliationWhereInput!]
  OR: [AffiliationWhereInput!]
  role: AffiliationRoleWhereInput
}

input AffiliationWhereUniqueInput {
  id: ID
}

type AggregateAffiliation {
  count: Int!
}

type AggregateAffiliationRole {
  count: Int!
}

type AggregateContactMetadata {
  count: Int!
}

type AggregateEmailAddress {
  count: Int!
}

type AggregateExternalLink {
  count: Int!
}

type AggregateFacilityMetadata {
  count: Int!
}

type AggregateGeometry {
  count: Int!
}

type AggregateGovernmentActor {
  count: Int!
}

type AggregateGovernmentActorProfile {
  count: Int!
}

type AggregateGovernmentBody {
  count: Int!
}

type AggregateGovernmentBodyMetadata {
  count: Int!
}

type AggregateGovernmentFacility {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateLocationMetadata {
  count: Int!
}

type AggregatePhoneNumber {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateUserProfile {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type ContactMetadata {
  id: ID!
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

type ContactMetadataConnection {
  aggregate: AggregateContactMetadata!
  edges: [ContactMetadataEdge!]!
  pageInfo: PageInfo!
}

input ContactMetadataCreateInput {
  id: ID
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

input ContactMetadataCreateOneInput {
  connect: ContactMetadataWhereUniqueInput
  create: ContactMetadataCreateInput
}

type ContactMetadataEdge {
  cursor: String!
  node: ContactMetadata!
}

enum ContactMetadataOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  isPrimary_ASC
  isPrimary_DESC
  isPublic_ASC
  isPublic_DESC
  isVerified_ASC
  isVerified_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ContactMetadataUpdateDataInput {
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

input ContactMetadataUpdateInput {
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

input ContactMetadataUpdateManyMutationInput {
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

input ContactMetadataUpdateOneRequiredInput {
  connect: ContactMetadataWhereUniqueInput
  create: ContactMetadataCreateInput
  update: ContactMetadataUpdateDataInput
  upsert: ContactMetadataUpsertNestedInput
}

input ContactMetadataUpsertNestedInput {
  create: ContactMetadataCreateInput!
  update: ContactMetadataUpdateDataInput!
}

input ContactMetadataWhereInput {
  AND: [ContactMetadataWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  isPrimary: Boolean
  isPrimary_not: Boolean
  isPublic: Boolean
  isPublic_not: Boolean
  isVerified: Boolean
  isVerified_not: Boolean
  NOT: [ContactMetadataWhereInput!]
  OR: [ContactMetadataWhereInput!]
}

input ContactMetadataWhereUniqueInput {
  id: ID
}

scalar DateTime

type EmailAddress {
  createdAt: DateTime!
  id: ID!
  metadata: ContactMetadata!
  payload: String!
  updatedAt: DateTime!
}

type EmailAddressConnection {
  aggregate: AggregateEmailAddress!
  edges: [EmailAddressEdge!]!
  pageInfo: PageInfo!
}

input EmailAddressCreateInput {
  id: ID
  metadata: ContactMetadataCreateOneInput!
  payload: String!
}

input EmailAddressCreateManyInput {
  connect: [EmailAddressWhereUniqueInput!]
  create: [EmailAddressCreateInput!]
}

input EmailAddressCreateOneInput {
  connect: EmailAddressWhereUniqueInput
  create: EmailAddressCreateInput
}

type EmailAddressEdge {
  cursor: String!
  node: EmailAddress!
}

enum EmailAddressOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  payload_ASC
  payload_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input EmailAddressScalarWhereInput {
  AND: [EmailAddressScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [EmailAddressScalarWhereInput!]
  OR: [EmailAddressScalarWhereInput!]
  payload: String
  payload_contains: String
  payload_ends_with: String
  payload_gt: String
  payload_gte: String
  payload_in: [String!]
  payload_lt: String
  payload_lte: String
  payload_not: String
  payload_not_contains: String
  payload_not_ends_with: String
  payload_not_in: [String!]
  payload_not_starts_with: String
  payload_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input EmailAddressUpdateDataInput {
  metadata: ContactMetadataUpdateOneRequiredInput
  payload: String
}

input EmailAddressUpdateInput {
  metadata: ContactMetadataUpdateOneRequiredInput
  payload: String
}

input EmailAddressUpdateManyDataInput {
  payload: String
}

input EmailAddressUpdateManyInput {
  connect: [EmailAddressWhereUniqueInput!]
  create: [EmailAddressCreateInput!]
  delete: [EmailAddressWhereUniqueInput!]
  deleteMany: [EmailAddressScalarWhereInput!]
  disconnect: [EmailAddressWhereUniqueInput!]
  set: [EmailAddressWhereUniqueInput!]
  update: [EmailAddressUpdateWithWhereUniqueNestedInput!]
  updateMany: [EmailAddressUpdateManyWithWhereNestedInput!]
  upsert: [EmailAddressUpsertWithWhereUniqueNestedInput!]
}

input EmailAddressUpdateManyMutationInput {
  payload: String
}

input EmailAddressUpdateManyWithWhereNestedInput {
  data: EmailAddressUpdateManyDataInput!
  where: EmailAddressScalarWhereInput!
}

input EmailAddressUpdateOneInput {
  connect: EmailAddressWhereUniqueInput
  create: EmailAddressCreateInput
  delete: Boolean
  disconnect: Boolean
  update: EmailAddressUpdateDataInput
  upsert: EmailAddressUpsertNestedInput
}

input EmailAddressUpdateWithWhereUniqueNestedInput {
  data: EmailAddressUpdateDataInput!
  where: EmailAddressWhereUniqueInput!
}

input EmailAddressUpsertNestedInput {
  create: EmailAddressCreateInput!
  update: EmailAddressUpdateDataInput!
}

input EmailAddressUpsertWithWhereUniqueNestedInput {
  create: EmailAddressCreateInput!
  update: EmailAddressUpdateDataInput!
  where: EmailAddressWhereUniqueInput!
}

input EmailAddressWhereInput {
  AND: [EmailAddressWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  metadata: ContactMetadataWhereInput
  NOT: [EmailAddressWhereInput!]
  OR: [EmailAddressWhereInput!]
  payload: String
  payload_contains: String
  payload_ends_with: String
  payload_gt: String
  payload_gte: String
  payload_in: [String!]
  payload_lt: String
  payload_lte: String
  payload_not: String
  payload_not_contains: String
  payload_not_ends_with: String
  payload_not_in: [String!]
  payload_not_starts_with: String
  payload_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input EmailAddressWhereUniqueInput {
  id: ID
  payload: String
}

type ExternalLink {
  createdAt: DateTime!
  id: ID!
  metadata: ContactMetadata!
  payload: String!
  updatedAt: DateTime!
}

type ExternalLinkConnection {
  aggregate: AggregateExternalLink!
  edges: [ExternalLinkEdge!]!
  pageInfo: PageInfo!
}

input ExternalLinkCreateInput {
  id: ID
  metadata: ContactMetadataCreateOneInput!
  payload: String!
}

input ExternalLinkCreateOneInput {
  connect: ExternalLinkWhereUniqueInput
  create: ExternalLinkCreateInput
}

type ExternalLinkEdge {
  cursor: String!
  node: ExternalLink!
}

enum ExternalLinkOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  payload_ASC
  payload_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ExternalLinkUpdateDataInput {
  metadata: ContactMetadataUpdateOneRequiredInput
  payload: String
}

input ExternalLinkUpdateInput {
  metadata: ContactMetadataUpdateOneRequiredInput
  payload: String
}

input ExternalLinkUpdateManyMutationInput {
  payload: String
}

input ExternalLinkUpdateOneInput {
  connect: ExternalLinkWhereUniqueInput
  create: ExternalLinkCreateInput
  delete: Boolean
  disconnect: Boolean
  update: ExternalLinkUpdateDataInput
  upsert: ExternalLinkUpsertNestedInput
}

input ExternalLinkUpsertNestedInput {
  create: ExternalLinkCreateInput!
  update: ExternalLinkUpdateDataInput!
}

input ExternalLinkWhereInput {
  AND: [ExternalLinkWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  metadata: ContactMetadataWhereInput
  NOT: [ExternalLinkWhereInput!]
  OR: [ExternalLinkWhereInput!]
  payload: String
  payload_contains: String
  payload_ends_with: String
  payload_gt: String
  payload_gte: String
  payload_in: [String!]
  payload_lt: String
  payload_lte: String
  payload_not: String
  payload_not_contains: String
  payload_not_ends_with: String
  payload_not_in: [String!]
  payload_not_starts_with: String
  payload_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ExternalLinkWhereUniqueInput {
  id: ID
  payload: String
}

type FacilityMetadata {
  id: ID!
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

type FacilityMetadataConnection {
  aggregate: AggregateFacilityMetadata!
  edges: [FacilityMetadataEdge!]!
  pageInfo: PageInfo!
}

input FacilityMetadataCreateInput {
  id: ID
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

input FacilityMetadataCreateOneInput {
  connect: FacilityMetadataWhereUniqueInput
  create: FacilityMetadataCreateInput
}

type FacilityMetadataEdge {
  cursor: String!
  node: FacilityMetadata!
}

enum FacilityMetadataOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  isPrimary_ASC
  isPrimary_DESC
  isPublic_ASC
  isPublic_DESC
  isVerified_ASC
  isVerified_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input FacilityMetadataUpdateDataInput {
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

input FacilityMetadataUpdateInput {
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

input FacilityMetadataUpdateManyMutationInput {
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

input FacilityMetadataUpdateOneRequiredInput {
  connect: FacilityMetadataWhereUniqueInput
  create: FacilityMetadataCreateInput
  update: FacilityMetadataUpdateDataInput
  upsert: FacilityMetadataUpsertNestedInput
}

input FacilityMetadataUpsertNestedInput {
  create: FacilityMetadataCreateInput!
  update: FacilityMetadataUpdateDataInput!
}

input FacilityMetadataWhereInput {
  AND: [FacilityMetadataWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  isPrimary: Boolean
  isPrimary_not: Boolean
  isPublic: Boolean
  isPublic_not: Boolean
  isVerified: Boolean
  isVerified_not: Boolean
  NOT: [FacilityMetadataWhereInput!]
  OR: [FacilityMetadataWhereInput!]
}

input FacilityMetadataWhereUniqueInput {
  id: ID
}

type Geometry {
  id: ID!
  lat: Float!
  lng: Float!
}

type GeometryConnection {
  aggregate: AggregateGeometry!
  edges: [GeometryEdge!]!
  pageInfo: PageInfo!
}

input GeometryCreateInput {
  id: ID
  lat: Float!
  lng: Float!
}

input GeometryCreateOneInput {
  connect: GeometryWhereUniqueInput
  create: GeometryCreateInput
}

type GeometryEdge {
  cursor: String!
  node: Geometry!
}

enum GeometryOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input GeometryUpdateDataInput {
  lat: Float
  lng: Float
}

input GeometryUpdateInput {
  lat: Float
  lng: Float
}

input GeometryUpdateManyMutationInput {
  lat: Float
  lng: Float
}

input GeometryUpdateOneInput {
  connect: GeometryWhereUniqueInput
  create: GeometryCreateInput
  delete: Boolean
  disconnect: Boolean
  update: GeometryUpdateDataInput
  upsert: GeometryUpsertNestedInput
}

input GeometryUpsertNestedInput {
  create: GeometryCreateInput!
  update: GeometryUpdateDataInput!
}

input GeometryWhereInput {
  AND: [GeometryWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  lat: Float
  lat_gt: Float
  lat_gte: Float
  lat_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_not: Float
  lat_not_in: [Float!]
  lng: Float
  lng_gt: Float
  lng_gte: Float
  lng_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_not: Float
  lng_not_in: [Float!]
  NOT: [GeometryWhereInput!]
  OR: [GeometryWhereInput!]
}

input GeometryWhereUniqueInput {
  id: ID
}

type GovernmentActor {
  affiliations(after: String, before: String, first: Int, last: Int, orderBy: AffiliationOrderByInput, skip: Int, where: AffiliationWhereInput): [Affiliation!]
  createdAt: DateTime!
  id: ID!
  profile: GovernmentActorProfile!
  updatedAt: DateTime!
}

type GovernmentActorConnection {
  aggregate: AggregateGovernmentActor!
  edges: [GovernmentActorEdge!]!
  pageInfo: PageInfo!
}

input GovernmentActorCreateInput {
  affiliations: AffiliationCreateManyWithoutActorInput
  id: ID
  profile: GovernmentActorProfileCreateOneInput!
}

input GovernmentActorCreateManyInput {
  connect: [GovernmentActorWhereUniqueInput!]
  create: [GovernmentActorCreateInput!]
}

input GovernmentActorCreateOneWithoutAffiliationsInput {
  connect: GovernmentActorWhereUniqueInput
  create: GovernmentActorCreateWithoutAffiliationsInput
}

input GovernmentActorCreateWithoutAffiliationsInput {
  id: ID
  profile: GovernmentActorProfileCreateOneInput!
}

type GovernmentActorEdge {
  cursor: String!
  node: GovernmentActor!
}

enum GovernmentActorOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GovernmentActorProfile {
  createdAt: DateTime!
  email(after: String, before: String, first: Int, last: Int, orderBy: EmailAddressOrderByInput, skip: Int, where: EmailAddressWhereInput): [EmailAddress!]
  firstName: String
  id: ID!
  lastName: String
  phone_number(after: String, before: String, first: Int, last: Int, orderBy: PhoneNumberOrderByInput, skip: Int, where: PhoneNumberWhereInput): [PhoneNumber!]
  updatedAt: DateTime!
}

type GovernmentActorProfileConnection {
  aggregate: AggregateGovernmentActorProfile!
  edges: [GovernmentActorProfileEdge!]!
  pageInfo: PageInfo!
}

input GovernmentActorProfileCreateInput {
  email: EmailAddressCreateManyInput
  firstName: String
  id: ID
  lastName: String
  phone_number: PhoneNumberCreateManyInput
}

input GovernmentActorProfileCreateOneInput {
  connect: GovernmentActorProfileWhereUniqueInput
  create: GovernmentActorProfileCreateInput
}

type GovernmentActorProfileEdge {
  cursor: String!
  node: GovernmentActorProfile!
}

enum GovernmentActorProfileOrderByInput {
  createdAt_ASC
  createdAt_DESC
  firstName_ASC
  firstName_DESC
  id_ASC
  id_DESC
  lastName_ASC
  lastName_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input GovernmentActorProfileUpdateDataInput {
  email: EmailAddressUpdateManyInput
  firstName: String
  lastName: String
  phone_number: PhoneNumberUpdateManyInput
}

input GovernmentActorProfileUpdateInput {
  email: EmailAddressUpdateManyInput
  firstName: String
  lastName: String
  phone_number: PhoneNumberUpdateManyInput
}

input GovernmentActorProfileUpdateManyMutationInput {
  firstName: String
  lastName: String
}

input GovernmentActorProfileUpdateOneRequiredInput {
  connect: GovernmentActorProfileWhereUniqueInput
  create: GovernmentActorProfileCreateInput
  update: GovernmentActorProfileUpdateDataInput
  upsert: GovernmentActorProfileUpsertNestedInput
}

input GovernmentActorProfileUpsertNestedInput {
  create: GovernmentActorProfileCreateInput!
  update: GovernmentActorProfileUpdateDataInput!
}

input GovernmentActorProfileWhereInput {
  AND: [GovernmentActorProfileWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email_every: EmailAddressWhereInput
  email_none: EmailAddressWhereInput
  email_some: EmailAddressWhereInput
  firstName: String
  firstName_contains: String
  firstName_ends_with: String
  firstName_gt: String
  firstName_gte: String
  firstName_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_not: String
  firstName_not_contains: String
  firstName_not_ends_with: String
  firstName_not_in: [String!]
  firstName_not_starts_with: String
  firstName_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  lastName: String
  lastName_contains: String
  lastName_ends_with: String
  lastName_gt: String
  lastName_gte: String
  lastName_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_not: String
  lastName_not_contains: String
  lastName_not_ends_with: String
  lastName_not_in: [String!]
  lastName_not_starts_with: String
  lastName_starts_with: String
  NOT: [GovernmentActorProfileWhereInput!]
  OR: [GovernmentActorProfileWhereInput!]
  phone_number_every: PhoneNumberWhereInput
  phone_number_none: PhoneNumberWhereInput
  phone_number_some: PhoneNumberWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input GovernmentActorProfileWhereUniqueInput {
  id: ID
}

input GovernmentActorScalarWhereInput {
  AND: [GovernmentActorScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [GovernmentActorScalarWhereInput!]
  OR: [GovernmentActorScalarWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input GovernmentActorUpdateDataInput {
  affiliations: AffiliationUpdateManyWithoutActorInput
  profile: GovernmentActorProfileUpdateOneRequiredInput
}

input GovernmentActorUpdateInput {
  affiliations: AffiliationUpdateManyWithoutActorInput
  profile: GovernmentActorProfileUpdateOneRequiredInput
}

input GovernmentActorUpdateManyInput {
  connect: [GovernmentActorWhereUniqueInput!]
  create: [GovernmentActorCreateInput!]
  delete: [GovernmentActorWhereUniqueInput!]
  deleteMany: [GovernmentActorScalarWhereInput!]
  disconnect: [GovernmentActorWhereUniqueInput!]
  set: [GovernmentActorWhereUniqueInput!]
  update: [GovernmentActorUpdateWithWhereUniqueNestedInput!]
  upsert: [GovernmentActorUpsertWithWhereUniqueNestedInput!]
}

input GovernmentActorUpdateOneRequiredWithoutAffiliationsInput {
  connect: GovernmentActorWhereUniqueInput
  create: GovernmentActorCreateWithoutAffiliationsInput
  update: GovernmentActorUpdateWithoutAffiliationsDataInput
  upsert: GovernmentActorUpsertWithoutAffiliationsInput
}

input GovernmentActorUpdateWithoutAffiliationsDataInput {
  profile: GovernmentActorProfileUpdateOneRequiredInput
}

input GovernmentActorUpdateWithWhereUniqueNestedInput {
  data: GovernmentActorUpdateDataInput!
  where: GovernmentActorWhereUniqueInput!
}

input GovernmentActorUpsertWithoutAffiliationsInput {
  create: GovernmentActorCreateWithoutAffiliationsInput!
  update: GovernmentActorUpdateWithoutAffiliationsDataInput!
}

input GovernmentActorUpsertWithWhereUniqueNestedInput {
  create: GovernmentActorCreateInput!
  update: GovernmentActorUpdateDataInput!
  where: GovernmentActorWhereUniqueInput!
}

input GovernmentActorWhereInput {
  affiliations_every: AffiliationWhereInput
  affiliations_none: AffiliationWhereInput
  affiliations_some: AffiliationWhereInput
  AND: [GovernmentActorWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [GovernmentActorWhereInput!]
  OR: [GovernmentActorWhereInput!]
  profile: GovernmentActorProfileWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input GovernmentActorWhereUniqueInput {
  id: ID
}

type GovernmentBody {
  abbr: String
  children(after: String, before: String, first: Int, last: Int, orderBy: GovernmentBodyOrderByInput, skip: Int, where: GovernmentBodyWhereInput): [GovernmentBody!]
  createdAt: DateTime!
  facilities(after: String, before: String, first: Int, last: Int, orderBy: GovernmentFacilityOrderByInput, skip: Int, where: GovernmentFacilityWhereInput): [GovernmentFacility!]
  id: ID!
  metadata: GovernmentBodyMetadata!
  name: String!
  parent: GovernmentBody
  updatedAt: DateTime!
}

type GovernmentBodyConnection {
  aggregate: AggregateGovernmentBody!
  edges: [GovernmentBodyEdge!]!
  pageInfo: PageInfo!
}

input GovernmentBodyCreateInput {
  abbr: String
  children: GovernmentBodyCreateManyWithoutChildrenInput
  facilities: GovernmentFacilityCreateManyInput
  id: ID
  metadata: GovernmentBodyMetadataCreateOneInput!
  name: String!
  parent: GovernmentBodyCreateOneWithoutParentInput
}

input GovernmentBodyCreateManyWithoutChildrenInput {
  connect: [GovernmentBodyWhereUniqueInput!]
  create: [GovernmentBodyCreateWithoutChildrenInput!]
}

input GovernmentBodyCreateOneInput {
  connect: GovernmentBodyWhereUniqueInput
  create: GovernmentBodyCreateInput
}

input GovernmentBodyCreateOneWithoutParentInput {
  connect: GovernmentBodyWhereUniqueInput
  create: GovernmentBodyCreateWithoutParentInput
}

input GovernmentBodyCreateWithoutChildrenInput {
  abbr: String
  facilities: GovernmentFacilityCreateManyInput
  id: ID
  metadata: GovernmentBodyMetadataCreateOneInput!
  name: String!
  parent: GovernmentBodyCreateOneWithoutParentInput
}

input GovernmentBodyCreateWithoutParentInput {
  abbr: String
  children: GovernmentBodyCreateManyWithoutChildrenInput
  facilities: GovernmentFacilityCreateManyInput
  id: ID
  metadata: GovernmentBodyMetadataCreateOneInput!
  name: String!
}

type GovernmentBodyEdge {
  cursor: String!
  node: GovernmentBody!
}

type GovernmentBodyMetadata {
  hasChildren: Boolean
  hasParent: Boolean
  id: ID!
}

type GovernmentBodyMetadataConnection {
  aggregate: AggregateGovernmentBodyMetadata!
  edges: [GovernmentBodyMetadataEdge!]!
  pageInfo: PageInfo!
}

input GovernmentBodyMetadataCreateInput {
  hasChildren: Boolean
  hasParent: Boolean
  id: ID
}

input GovernmentBodyMetadataCreateOneInput {
  connect: GovernmentBodyMetadataWhereUniqueInput
  create: GovernmentBodyMetadataCreateInput
}

type GovernmentBodyMetadataEdge {
  cursor: String!
  node: GovernmentBodyMetadata!
}

enum GovernmentBodyMetadataOrderByInput {
  createdAt_ASC
  createdAt_DESC
  hasChildren_ASC
  hasChildren_DESC
  hasParent_ASC
  hasParent_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input GovernmentBodyMetadataUpdateDataInput {
  hasChildren: Boolean
  hasParent: Boolean
}

input GovernmentBodyMetadataUpdateInput {
  hasChildren: Boolean
  hasParent: Boolean
}

input GovernmentBodyMetadataUpdateManyMutationInput {
  hasChildren: Boolean
  hasParent: Boolean
}

input GovernmentBodyMetadataUpdateOneRequiredInput {
  connect: GovernmentBodyMetadataWhereUniqueInput
  create: GovernmentBodyMetadataCreateInput
  update: GovernmentBodyMetadataUpdateDataInput
  upsert: GovernmentBodyMetadataUpsertNestedInput
}

input GovernmentBodyMetadataUpsertNestedInput {
  create: GovernmentBodyMetadataCreateInput!
  update: GovernmentBodyMetadataUpdateDataInput!
}

input GovernmentBodyMetadataWhereInput {
  AND: [GovernmentBodyMetadataWhereInput!]
  hasChildren: Boolean
  hasChildren_not: Boolean
  hasParent: Boolean
  hasParent_not: Boolean
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [GovernmentBodyMetadataWhereInput!]
  OR: [GovernmentBodyMetadataWhereInput!]
}

input GovernmentBodyMetadataWhereUniqueInput {
  id: ID
}

enum GovernmentBodyOrderByInput {
  abbr_ASC
  abbr_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input GovernmentBodyScalarWhereInput {
  abbr: String
  abbr_contains: String
  abbr_ends_with: String
  abbr_gt: String
  abbr_gte: String
  abbr_in: [String!]
  abbr_lt: String
  abbr_lte: String
  abbr_not: String
  abbr_not_contains: String
  abbr_not_ends_with: String
  abbr_not_in: [String!]
  abbr_not_starts_with: String
  abbr_starts_with: String
  AND: [GovernmentBodyScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [GovernmentBodyScalarWhereInput!]
  OR: [GovernmentBodyScalarWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input GovernmentBodyUpdateDataInput {
  abbr: String
  children: GovernmentBodyUpdateManyWithoutChildrenInput
  facilities: GovernmentFacilityUpdateManyInput
  metadata: GovernmentBodyMetadataUpdateOneRequiredInput
  name: String
  parent: GovernmentBodyUpdateOneWithoutParentInput
}

input GovernmentBodyUpdateInput {
  abbr: String
  children: GovernmentBodyUpdateManyWithoutChildrenInput
  facilities: GovernmentFacilityUpdateManyInput
  metadata: GovernmentBodyMetadataUpdateOneRequiredInput
  name: String
  parent: GovernmentBodyUpdateOneWithoutParentInput
}

input GovernmentBodyUpdateManyDataInput {
  abbr: String
  name: String
}

input GovernmentBodyUpdateManyMutationInput {
  abbr: String
  name: String
}

input GovernmentBodyUpdateManyWithoutChildrenInput {
  connect: [GovernmentBodyWhereUniqueInput!]
  create: [GovernmentBodyCreateWithoutChildrenInput!]
  delete: [GovernmentBodyWhereUniqueInput!]
  deleteMany: [GovernmentBodyScalarWhereInput!]
  disconnect: [GovernmentBodyWhereUniqueInput!]
  set: [GovernmentBodyWhereUniqueInput!]
  update: [GovernmentBodyUpdateWithWhereUniqueWithoutChildrenInput!]
  updateMany: [GovernmentBodyUpdateManyWithWhereNestedInput!]
  upsert: [GovernmentBodyUpsertWithWhereUniqueWithoutChildrenInput!]
}

input GovernmentBodyUpdateManyWithWhereNestedInput {
  data: GovernmentBodyUpdateManyDataInput!
  where: GovernmentBodyScalarWhereInput!
}

input GovernmentBodyUpdateOneRequiredInput {
  connect: GovernmentBodyWhereUniqueInput
  create: GovernmentBodyCreateInput
  update: GovernmentBodyUpdateDataInput
  upsert: GovernmentBodyUpsertNestedInput
}

input GovernmentBodyUpdateOneWithoutParentInput {
  connect: GovernmentBodyWhereUniqueInput
  create: GovernmentBodyCreateWithoutParentInput
  delete: Boolean
  disconnect: Boolean
  update: GovernmentBodyUpdateWithoutParentDataInput
  upsert: GovernmentBodyUpsertWithoutParentInput
}

input GovernmentBodyUpdateWithoutChildrenDataInput {
  abbr: String
  facilities: GovernmentFacilityUpdateManyInput
  metadata: GovernmentBodyMetadataUpdateOneRequiredInput
  name: String
  parent: GovernmentBodyUpdateOneWithoutParentInput
}

input GovernmentBodyUpdateWithoutParentDataInput {
  abbr: String
  children: GovernmentBodyUpdateManyWithoutChildrenInput
  facilities: GovernmentFacilityUpdateManyInput
  metadata: GovernmentBodyMetadataUpdateOneRequiredInput
  name: String
}

input GovernmentBodyUpdateWithWhereUniqueWithoutChildrenInput {
  data: GovernmentBodyUpdateWithoutChildrenDataInput!
  where: GovernmentBodyWhereUniqueInput!
}

input GovernmentBodyUpsertNestedInput {
  create: GovernmentBodyCreateInput!
  update: GovernmentBodyUpdateDataInput!
}

input GovernmentBodyUpsertWithoutParentInput {
  create: GovernmentBodyCreateWithoutParentInput!
  update: GovernmentBodyUpdateWithoutParentDataInput!
}

input GovernmentBodyUpsertWithWhereUniqueWithoutChildrenInput {
  create: GovernmentBodyCreateWithoutChildrenInput!
  update: GovernmentBodyUpdateWithoutChildrenDataInput!
  where: GovernmentBodyWhereUniqueInput!
}

input GovernmentBodyWhereInput {
  abbr: String
  abbr_contains: String
  abbr_ends_with: String
  abbr_gt: String
  abbr_gte: String
  abbr_in: [String!]
  abbr_lt: String
  abbr_lte: String
  abbr_not: String
  abbr_not_contains: String
  abbr_not_ends_with: String
  abbr_not_in: [String!]
  abbr_not_starts_with: String
  abbr_starts_with: String
  AND: [GovernmentBodyWhereInput!]
  children_every: GovernmentBodyWhereInput
  children_none: GovernmentBodyWhereInput
  children_some: GovernmentBodyWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  facilities_every: GovernmentFacilityWhereInput
  facilities_none: GovernmentFacilityWhereInput
  facilities_some: GovernmentFacilityWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  metadata: GovernmentBodyMetadataWhereInput
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [GovernmentBodyWhereInput!]
  OR: [GovernmentBodyWhereInput!]
  parent: GovernmentBodyWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input GovernmentBodyWhereUniqueInput {
  id: ID
}

type GovernmentFacility {
  actors(after: String, before: String, first: Int, last: Int, orderBy: GovernmentActorOrderByInput, skip: Int, where: GovernmentActorWhereInput): [GovernmentActor!]
  createdAt: DateTime!
  email: EmailAddress
  fax: PhoneNumber
  id: ID!
  location: Location!
  metadata: FacilityMetadata!
  name: String
  phone: PhoneNumber
  type: GovernmentFacilityType!
  updatedAt: DateTime!
  url: ExternalLink
}

type GovernmentFacilityConnection {
  aggregate: AggregateGovernmentFacility!
  edges: [GovernmentFacilityEdge!]!
  pageInfo: PageInfo!
}

input GovernmentFacilityCreateInput {
  actors: GovernmentActorCreateManyInput
  email: EmailAddressCreateOneInput
  fax: PhoneNumberCreateOneInput
  id: ID
  location: LocationCreateOneInput!
  metadata: FacilityMetadataCreateOneInput!
  name: String
  phone: PhoneNumberCreateOneInput
  type: GovernmentFacilityType!
  url: ExternalLinkCreateOneInput
}

input GovernmentFacilityCreateManyInput {
  connect: [GovernmentFacilityWhereUniqueInput!]
  create: [GovernmentFacilityCreateInput!]
}

type GovernmentFacilityEdge {
  cursor: String!
  node: GovernmentFacility!
}

enum GovernmentFacilityOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input GovernmentFacilityScalarWhereInput {
  AND: [GovernmentFacilityScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [GovernmentFacilityScalarWhereInput!]
  OR: [GovernmentFacilityScalarWhereInput!]
  type: GovernmentFacilityType
  type_in: [GovernmentFacilityType!]
  type_not: GovernmentFacilityType
  type_not_in: [GovernmentFacilityType!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

enum GovernmentFacilityType {
  COURT
  DETENTION_CENTER
  FIELD_OFFICE
}

input GovernmentFacilityUpdateDataInput {
  actors: GovernmentActorUpdateManyInput
  email: EmailAddressUpdateOneInput
  fax: PhoneNumberUpdateOneInput
  location: LocationUpdateOneRequiredInput
  metadata: FacilityMetadataUpdateOneRequiredInput
  name: String
  phone: PhoneNumberUpdateOneInput
  type: GovernmentFacilityType
  url: ExternalLinkUpdateOneInput
}

input GovernmentFacilityUpdateInput {
  actors: GovernmentActorUpdateManyInput
  email: EmailAddressUpdateOneInput
  fax: PhoneNumberUpdateOneInput
  location: LocationUpdateOneRequiredInput
  metadata: FacilityMetadataUpdateOneRequiredInput
  name: String
  phone: PhoneNumberUpdateOneInput
  type: GovernmentFacilityType
  url: ExternalLinkUpdateOneInput
}

input GovernmentFacilityUpdateManyDataInput {
  name: String
  type: GovernmentFacilityType
}

input GovernmentFacilityUpdateManyInput {
  connect: [GovernmentFacilityWhereUniqueInput!]
  create: [GovernmentFacilityCreateInput!]
  delete: [GovernmentFacilityWhereUniqueInput!]
  deleteMany: [GovernmentFacilityScalarWhereInput!]
  disconnect: [GovernmentFacilityWhereUniqueInput!]
  set: [GovernmentFacilityWhereUniqueInput!]
  update: [GovernmentFacilityUpdateWithWhereUniqueNestedInput!]
  updateMany: [GovernmentFacilityUpdateManyWithWhereNestedInput!]
  upsert: [GovernmentFacilityUpsertWithWhereUniqueNestedInput!]
}

input GovernmentFacilityUpdateManyMutationInput {
  name: String
  type: GovernmentFacilityType
}

input GovernmentFacilityUpdateManyWithWhereNestedInput {
  data: GovernmentFacilityUpdateManyDataInput!
  where: GovernmentFacilityScalarWhereInput!
}

input GovernmentFacilityUpdateWithWhereUniqueNestedInput {
  data: GovernmentFacilityUpdateDataInput!
  where: GovernmentFacilityWhereUniqueInput!
}

input GovernmentFacilityUpsertWithWhereUniqueNestedInput {
  create: GovernmentFacilityCreateInput!
  update: GovernmentFacilityUpdateDataInput!
  where: GovernmentFacilityWhereUniqueInput!
}

input GovernmentFacilityWhereInput {
  actors_every: GovernmentActorWhereInput
  actors_none: GovernmentActorWhereInput
  actors_some: GovernmentActorWhereInput
  AND: [GovernmentFacilityWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email: EmailAddressWhereInput
  fax: PhoneNumberWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  location: LocationWhereInput
  metadata: FacilityMetadataWhereInput
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [GovernmentFacilityWhereInput!]
  OR: [GovernmentFacilityWhereInput!]
  phone: PhoneNumberWhereInput
  type: GovernmentFacilityType
  type_in: [GovernmentFacilityType!]
  type_not: GovernmentFacilityType
  type_not_in: [GovernmentFacilityType!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
  url: ExternalLinkWhereInput
}

input GovernmentFacilityWhereUniqueInput {
  id: ID
}

scalar Json

type Location {
  createdAt: DateTime!
  formatted_address: String
  googleId: String
  id: ID!
  location: Geometry
  metadata: LocationMetadata!
  placeId: String
  updatedAt: DateTime!
}

type LocationConnection {
  aggregate: AggregateLocation!
  edges: [LocationEdge!]!
  pageInfo: PageInfo!
}

input LocationCreateInput {
  formatted_address: String
  googleId: String
  id: ID
  location: GeometryCreateOneInput
  metadata: LocationMetadataCreateOneInput!
  placeId: String
}

input LocationCreateOneInput {
  connect: LocationWhereUniqueInput
  create: LocationCreateInput
}

type LocationEdge {
  cursor: String!
  node: Location!
}

type LocationMetadata {
  id: ID!
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

type LocationMetadataConnection {
  aggregate: AggregateLocationMetadata!
  edges: [LocationMetadataEdge!]!
  pageInfo: PageInfo!
}

input LocationMetadataCreateInput {
  id: ID
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

input LocationMetadataCreateOneInput {
  connect: LocationMetadataWhereUniqueInput
  create: LocationMetadataCreateInput
}

type LocationMetadataEdge {
  cursor: String!
  node: LocationMetadata!
}

enum LocationMetadataOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  isPrimary_ASC
  isPrimary_DESC
  isPublic_ASC
  isPublic_DESC
  isVerified_ASC
  isVerified_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input LocationMetadataUpdateDataInput {
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

input LocationMetadataUpdateInput {
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

input LocationMetadataUpdateManyMutationInput {
  isPrimary: Boolean
  isPublic: Boolean
  isVerified: Boolean
}

input LocationMetadataUpdateOneRequiredInput {
  connect: LocationMetadataWhereUniqueInput
  create: LocationMetadataCreateInput
  update: LocationMetadataUpdateDataInput
  upsert: LocationMetadataUpsertNestedInput
}

input LocationMetadataUpsertNestedInput {
  create: LocationMetadataCreateInput!
  update: LocationMetadataUpdateDataInput!
}

input LocationMetadataWhereInput {
  AND: [LocationMetadataWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  isPrimary: Boolean
  isPrimary_not: Boolean
  isPublic: Boolean
  isPublic_not: Boolean
  isVerified: Boolean
  isVerified_not: Boolean
  NOT: [LocationMetadataWhereInput!]
  OR: [LocationMetadataWhereInput!]
}

input LocationMetadataWhereUniqueInput {
  id: ID
}

enum LocationOrderByInput {
  createdAt_ASC
  createdAt_DESC
  formatted_address_ASC
  formatted_address_DESC
  googleId_ASC
  googleId_DESC
  id_ASC
  id_DESC
  placeId_ASC
  placeId_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input LocationUpdateDataInput {
  formatted_address: String
  googleId: String
  location: GeometryUpdateOneInput
  metadata: LocationMetadataUpdateOneRequiredInput
  placeId: String
}

input LocationUpdateInput {
  formatted_address: String
  googleId: String
  location: GeometryUpdateOneInput
  metadata: LocationMetadataUpdateOneRequiredInput
  placeId: String
}

input LocationUpdateManyMutationInput {
  formatted_address: String
  googleId: String
  placeId: String
}

input LocationUpdateOneRequiredInput {
  connect: LocationWhereUniqueInput
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
}

input LocationUpsertNestedInput {
  create: LocationCreateInput!
  update: LocationUpdateDataInput!
}

input LocationWhereInput {
  AND: [LocationWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  formatted_address: String
  formatted_address_contains: String
  formatted_address_ends_with: String
  formatted_address_gt: String
  formatted_address_gte: String
  formatted_address_in: [String!]
  formatted_address_lt: String
  formatted_address_lte: String
  formatted_address_not: String
  formatted_address_not_contains: String
  formatted_address_not_ends_with: String
  formatted_address_not_in: [String!]
  formatted_address_not_starts_with: String
  formatted_address_starts_with: String
  googleId: String
  googleId_contains: String
  googleId_ends_with: String
  googleId_gt: String
  googleId_gte: String
  googleId_in: [String!]
  googleId_lt: String
  googleId_lte: String
  googleId_not: String
  googleId_not_contains: String
  googleId_not_ends_with: String
  googleId_not_in: [String!]
  googleId_not_starts_with: String
  googleId_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  location: GeometryWhereInput
  metadata: LocationMetadataWhereInput
  NOT: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  placeId: String
  placeId_contains: String
  placeId_ends_with: String
  placeId_gt: String
  placeId_gte: String
  placeId_in: [String!]
  placeId_lt: String
  placeId_lte: String
  placeId_not: String
  placeId_not_contains: String
  placeId_not_ends_with: String
  placeId_not_in: [String!]
  placeId_not_starts_with: String
  placeId_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAffiliation(data: AffiliationCreateInput!): Affiliation!
  createAffiliationRole(data: AffiliationRoleCreateInput!): AffiliationRole!
  createContactMetadata(data: ContactMetadataCreateInput!): ContactMetadata!
  createEmailAddress(data: EmailAddressCreateInput!): EmailAddress!
  createExternalLink(data: ExternalLinkCreateInput!): ExternalLink!
  createFacilityMetadata(data: FacilityMetadataCreateInput!): FacilityMetadata!
  createGeometry(data: GeometryCreateInput!): Geometry!
  createGovernmentActor(data: GovernmentActorCreateInput!): GovernmentActor!
  createGovernmentActorProfile(data: GovernmentActorProfileCreateInput!): GovernmentActorProfile!
  createGovernmentBody(data: GovernmentBodyCreateInput!): GovernmentBody!
  createGovernmentBodyMetadata(data: GovernmentBodyMetadataCreateInput!): GovernmentBodyMetadata!
  createGovernmentFacility(data: GovernmentFacilityCreateInput!): GovernmentFacility!
  createLocation(data: LocationCreateInput!): Location!
  createLocationMetadata(data: LocationMetadataCreateInput!): LocationMetadata!
  createPhoneNumber(data: PhoneNumberCreateInput!): PhoneNumber!
  createUser(data: UserCreateInput!): User!
  createUserProfile(data: UserProfileCreateInput!): UserProfile!
  deleteAffiliation(where: AffiliationWhereUniqueInput!): Affiliation
  deleteAffiliationRole(where: AffiliationRoleWhereUniqueInput!): AffiliationRole
  deleteContactMetadata(where: ContactMetadataWhereUniqueInput!): ContactMetadata
  deleteEmailAddress(where: EmailAddressWhereUniqueInput!): EmailAddress
  deleteExternalLink(where: ExternalLinkWhereUniqueInput!): ExternalLink
  deleteFacilityMetadata(where: FacilityMetadataWhereUniqueInput!): FacilityMetadata
  deleteGeometry(where: GeometryWhereUniqueInput!): Geometry
  deleteGovernmentActor(where: GovernmentActorWhereUniqueInput!): GovernmentActor
  deleteGovernmentActorProfile(where: GovernmentActorProfileWhereUniqueInput!): GovernmentActorProfile
  deleteGovernmentBody(where: GovernmentBodyWhereUniqueInput!): GovernmentBody
  deleteGovernmentBodyMetadata(where: GovernmentBodyMetadataWhereUniqueInput!): GovernmentBodyMetadata
  deleteGovernmentFacility(where: GovernmentFacilityWhereUniqueInput!): GovernmentFacility
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteLocationMetadata(where: LocationMetadataWhereUniqueInput!): LocationMetadata
  deleteManyAffiliationRoles(where: AffiliationRoleWhereInput): BatchPayload!
  deleteManyAffiliations(where: AffiliationWhereInput): BatchPayload!
  deleteManyContactMetadatas(where: ContactMetadataWhereInput): BatchPayload!
  deleteManyEmailAddresses(where: EmailAddressWhereInput): BatchPayload!
  deleteManyExternalLinks(where: ExternalLinkWhereInput): BatchPayload!
  deleteManyFacilityMetadatas(where: FacilityMetadataWhereInput): BatchPayload!
  deleteManyGeometries(where: GeometryWhereInput): BatchPayload!
  deleteManyGovernmentActorProfiles(where: GovernmentActorProfileWhereInput): BatchPayload!
  deleteManyGovernmentActors(where: GovernmentActorWhereInput): BatchPayload!
  deleteManyGovernmentBodies(where: GovernmentBodyWhereInput): BatchPayload!
  deleteManyGovernmentBodyMetadatas(where: GovernmentBodyMetadataWhereInput): BatchPayload!
  deleteManyGovernmentFacilities(where: GovernmentFacilityWhereInput): BatchPayload!
  deleteManyLocationMetadatas(where: LocationMetadataWhereInput): BatchPayload!
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  deleteManyPhoneNumbers(where: PhoneNumberWhereInput): BatchPayload!
  deleteManyUserProfiles(where: UserProfileWhereInput): BatchPayload!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deletePhoneNumber(where: PhoneNumberWhereUniqueInput!): PhoneNumber
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUserProfile(where: UserProfileWhereUniqueInput!): UserProfile
  updateAffiliation(data: AffiliationUpdateInput!, where: AffiliationWhereUniqueInput!): Affiliation
  updateAffiliationRole(data: AffiliationRoleUpdateInput!, where: AffiliationRoleWhereUniqueInput!): AffiliationRole
  updateContactMetadata(data: ContactMetadataUpdateInput!, where: ContactMetadataWhereUniqueInput!): ContactMetadata
  updateEmailAddress(data: EmailAddressUpdateInput!, where: EmailAddressWhereUniqueInput!): EmailAddress
  updateExternalLink(data: ExternalLinkUpdateInput!, where: ExternalLinkWhereUniqueInput!): ExternalLink
  updateFacilityMetadata(data: FacilityMetadataUpdateInput!, where: FacilityMetadataWhereUniqueInput!): FacilityMetadata
  updateGeometry(data: GeometryUpdateInput!, where: GeometryWhereUniqueInput!): Geometry
  updateGovernmentActor(data: GovernmentActorUpdateInput!, where: GovernmentActorWhereUniqueInput!): GovernmentActor
  updateGovernmentActorProfile(data: GovernmentActorProfileUpdateInput!, where: GovernmentActorProfileWhereUniqueInput!): GovernmentActorProfile
  updateGovernmentBody(data: GovernmentBodyUpdateInput!, where: GovernmentBodyWhereUniqueInput!): GovernmentBody
  updateGovernmentBodyMetadata(data: GovernmentBodyMetadataUpdateInput!, where: GovernmentBodyMetadataWhereUniqueInput!): GovernmentBodyMetadata
  updateGovernmentFacility(data: GovernmentFacilityUpdateInput!, where: GovernmentFacilityWhereUniqueInput!): GovernmentFacility
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateLocationMetadata(data: LocationMetadataUpdateInput!, where: LocationMetadataWhereUniqueInput!): LocationMetadata
  updateManyAffiliationRoles(data: AffiliationRoleUpdateManyMutationInput!, where: AffiliationRoleWhereInput): BatchPayload!
  updateManyAffiliations(data: AffiliationUpdateManyMutationInput!, where: AffiliationWhereInput): BatchPayload!
  updateManyContactMetadatas(data: ContactMetadataUpdateManyMutationInput!, where: ContactMetadataWhereInput): BatchPayload!
  updateManyEmailAddresses(data: EmailAddressUpdateManyMutationInput!, where: EmailAddressWhereInput): BatchPayload!
  updateManyExternalLinks(data: ExternalLinkUpdateManyMutationInput!, where: ExternalLinkWhereInput): BatchPayload!
  updateManyFacilityMetadatas(data: FacilityMetadataUpdateManyMutationInput!, where: FacilityMetadataWhereInput): BatchPayload!
  updateManyGeometries(data: GeometryUpdateManyMutationInput!, where: GeometryWhereInput): BatchPayload!
  updateManyGovernmentActorProfiles(data: GovernmentActorProfileUpdateManyMutationInput!, where: GovernmentActorProfileWhereInput): BatchPayload!
  updateManyGovernmentBodies(data: GovernmentBodyUpdateManyMutationInput!, where: GovernmentBodyWhereInput): BatchPayload!
  updateManyGovernmentBodyMetadatas(data: GovernmentBodyMetadataUpdateManyMutationInput!, where: GovernmentBodyMetadataWhereInput): BatchPayload!
  updateManyGovernmentFacilities(data: GovernmentFacilityUpdateManyMutationInput!, where: GovernmentFacilityWhereInput): BatchPayload!
  updateManyLocationMetadatas(data: LocationMetadataUpdateManyMutationInput!, where: LocationMetadataWhereInput): BatchPayload!
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  updateManyPhoneNumbers(data: PhoneNumberUpdateManyMutationInput!, where: PhoneNumberWhereInput): BatchPayload!
  updateManyUserProfiles(data: UserProfileUpdateManyMutationInput!, where: UserProfileWhereInput): BatchPayload!
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updatePhoneNumber(data: PhoneNumberUpdateInput!, where: PhoneNumberWhereUniqueInput!): PhoneNumber
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateUserProfile(data: UserProfileUpdateInput!, where: UserProfileWhereUniqueInput!): UserProfile
  upsertAffiliation(create: AffiliationCreateInput!, update: AffiliationUpdateInput!, where: AffiliationWhereUniqueInput!): Affiliation!
  upsertAffiliationRole(create: AffiliationRoleCreateInput!, update: AffiliationRoleUpdateInput!, where: AffiliationRoleWhereUniqueInput!): AffiliationRole!
  upsertContactMetadata(create: ContactMetadataCreateInput!, update: ContactMetadataUpdateInput!, where: ContactMetadataWhereUniqueInput!): ContactMetadata!
  upsertEmailAddress(create: EmailAddressCreateInput!, update: EmailAddressUpdateInput!, where: EmailAddressWhereUniqueInput!): EmailAddress!
  upsertExternalLink(create: ExternalLinkCreateInput!, update: ExternalLinkUpdateInput!, where: ExternalLinkWhereUniqueInput!): ExternalLink!
  upsertFacilityMetadata(create: FacilityMetadataCreateInput!, update: FacilityMetadataUpdateInput!, where: FacilityMetadataWhereUniqueInput!): FacilityMetadata!
  upsertGeometry(create: GeometryCreateInput!, update: GeometryUpdateInput!, where: GeometryWhereUniqueInput!): Geometry!
  upsertGovernmentActor(create: GovernmentActorCreateInput!, update: GovernmentActorUpdateInput!, where: GovernmentActorWhereUniqueInput!): GovernmentActor!
  upsertGovernmentActorProfile(create: GovernmentActorProfileCreateInput!, update: GovernmentActorProfileUpdateInput!, where: GovernmentActorProfileWhereUniqueInput!): GovernmentActorProfile!
  upsertGovernmentBody(create: GovernmentBodyCreateInput!, update: GovernmentBodyUpdateInput!, where: GovernmentBodyWhereUniqueInput!): GovernmentBody!
  upsertGovernmentBodyMetadata(create: GovernmentBodyMetadataCreateInput!, update: GovernmentBodyMetadataUpdateInput!, where: GovernmentBodyMetadataWhereUniqueInput!): GovernmentBodyMetadata!
  upsertGovernmentFacility(create: GovernmentFacilityCreateInput!, update: GovernmentFacilityUpdateInput!, where: GovernmentFacilityWhereUniqueInput!): GovernmentFacility!
  upsertLocation(create: LocationCreateInput!, update: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location!
  upsertLocationMetadata(create: LocationMetadataCreateInput!, update: LocationMetadataUpdateInput!, where: LocationMetadataWhereUniqueInput!): LocationMetadata!
  upsertPhoneNumber(create: PhoneNumberCreateInput!, update: PhoneNumberUpdateInput!, where: PhoneNumberWhereUniqueInput!): PhoneNumber!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertUserProfile(create: UserProfileCreateInput!, update: UserProfileUpdateInput!, where: UserProfileWhereUniqueInput!): UserProfile!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type PhoneNumber {
  createdAt: DateTime!
  id: ID!
  metadata: ContactMetadata!
  payload: String!
  updatedAt: DateTime!
}

type PhoneNumberConnection {
  aggregate: AggregatePhoneNumber!
  edges: [PhoneNumberEdge!]!
  pageInfo: PageInfo!
}

input PhoneNumberCreateInput {
  id: ID
  metadata: ContactMetadataCreateOneInput!
  payload: String!
}

input PhoneNumberCreateManyInput {
  connect: [PhoneNumberWhereUniqueInput!]
  create: [PhoneNumberCreateInput!]
}

input PhoneNumberCreateOneInput {
  connect: PhoneNumberWhereUniqueInput
  create: PhoneNumberCreateInput
}

type PhoneNumberEdge {
  cursor: String!
  node: PhoneNumber!
}

enum PhoneNumberOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  payload_ASC
  payload_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input PhoneNumberScalarWhereInput {
  AND: [PhoneNumberScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [PhoneNumberScalarWhereInput!]
  OR: [PhoneNumberScalarWhereInput!]
  payload: String
  payload_contains: String
  payload_ends_with: String
  payload_gt: String
  payload_gte: String
  payload_in: [String!]
  payload_lt: String
  payload_lte: String
  payload_not: String
  payload_not_contains: String
  payload_not_ends_with: String
  payload_not_in: [String!]
  payload_not_starts_with: String
  payload_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PhoneNumberUpdateDataInput {
  metadata: ContactMetadataUpdateOneRequiredInput
  payload: String
}

input PhoneNumberUpdateInput {
  metadata: ContactMetadataUpdateOneRequiredInput
  payload: String
}

input PhoneNumberUpdateManyDataInput {
  payload: String
}

input PhoneNumberUpdateManyInput {
  connect: [PhoneNumberWhereUniqueInput!]
  create: [PhoneNumberCreateInput!]
  delete: [PhoneNumberWhereUniqueInput!]
  deleteMany: [PhoneNumberScalarWhereInput!]
  disconnect: [PhoneNumberWhereUniqueInput!]
  set: [PhoneNumberWhereUniqueInput!]
  update: [PhoneNumberUpdateWithWhereUniqueNestedInput!]
  updateMany: [PhoneNumberUpdateManyWithWhereNestedInput!]
  upsert: [PhoneNumberUpsertWithWhereUniqueNestedInput!]
}

input PhoneNumberUpdateManyMutationInput {
  payload: String
}

input PhoneNumberUpdateManyWithWhereNestedInput {
  data: PhoneNumberUpdateManyDataInput!
  where: PhoneNumberScalarWhereInput!
}

input PhoneNumberUpdateOneInput {
  connect: PhoneNumberWhereUniqueInput
  create: PhoneNumberCreateInput
  delete: Boolean
  disconnect: Boolean
  update: PhoneNumberUpdateDataInput
  upsert: PhoneNumberUpsertNestedInput
}

input PhoneNumberUpdateWithWhereUniqueNestedInput {
  data: PhoneNumberUpdateDataInput!
  where: PhoneNumberWhereUniqueInput!
}

input PhoneNumberUpsertNestedInput {
  create: PhoneNumberCreateInput!
  update: PhoneNumberUpdateDataInput!
}

input PhoneNumberUpsertWithWhereUniqueNestedInput {
  create: PhoneNumberCreateInput!
  update: PhoneNumberUpdateDataInput!
  where: PhoneNumberWhereUniqueInput!
}

input PhoneNumberWhereInput {
  AND: [PhoneNumberWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  metadata: ContactMetadataWhereInput
  NOT: [PhoneNumberWhereInput!]
  OR: [PhoneNumberWhereInput!]
  payload: String
  payload_contains: String
  payload_ends_with: String
  payload_gt: String
  payload_gte: String
  payload_in: [String!]
  payload_lt: String
  payload_lte: String
  payload_not: String
  payload_not_contains: String
  payload_not_ends_with: String
  payload_not_in: [String!]
  payload_not_starts_with: String
  payload_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PhoneNumberWhereUniqueInput {
  id: ID
  payload: String
}

type Query {
  affiliation(where: AffiliationWhereUniqueInput!): Affiliation
  affiliationRole(where: AffiliationRoleWhereUniqueInput!): AffiliationRole
  affiliationRoles(after: String, before: String, first: Int, last: Int, orderBy: AffiliationRoleOrderByInput, skip: Int, where: AffiliationRoleWhereInput): [AffiliationRole!]!
  affiliationRolesConnection(after: String, before: String, first: Int, last: Int, orderBy: AffiliationRoleOrderByInput, skip: Int, where: AffiliationRoleWhereInput): AffiliationRoleConnection!
  affiliations(after: String, before: String, first: Int, last: Int, orderBy: AffiliationOrderByInput, skip: Int, where: AffiliationWhereInput): [Affiliation!]!
  affiliationsConnection(after: String, before: String, first: Int, last: Int, orderBy: AffiliationOrderByInput, skip: Int, where: AffiliationWhereInput): AffiliationConnection!
  contactMetadata(where: ContactMetadataWhereUniqueInput!): ContactMetadata
  contactMetadatas(after: String, before: String, first: Int, last: Int, orderBy: ContactMetadataOrderByInput, skip: Int, where: ContactMetadataWhereInput): [ContactMetadata!]!
  contactMetadatasConnection(after: String, before: String, first: Int, last: Int, orderBy: ContactMetadataOrderByInput, skip: Int, where: ContactMetadataWhereInput): ContactMetadataConnection!
  emailAddress(where: EmailAddressWhereUniqueInput!): EmailAddress
  emailAddresses(after: String, before: String, first: Int, last: Int, orderBy: EmailAddressOrderByInput, skip: Int, where: EmailAddressWhereInput): [EmailAddress!]!
  emailAddressesConnection(after: String, before: String, first: Int, last: Int, orderBy: EmailAddressOrderByInput, skip: Int, where: EmailAddressWhereInput): EmailAddressConnection!
  externalLink(where: ExternalLinkWhereUniqueInput!): ExternalLink
  externalLinks(after: String, before: String, first: Int, last: Int, orderBy: ExternalLinkOrderByInput, skip: Int, where: ExternalLinkWhereInput): [ExternalLink!]!
  externalLinksConnection(after: String, before: String, first: Int, last: Int, orderBy: ExternalLinkOrderByInput, skip: Int, where: ExternalLinkWhereInput): ExternalLinkConnection!
  facilityMetadata(where: FacilityMetadataWhereUniqueInput!): FacilityMetadata
  facilityMetadatas(after: String, before: String, first: Int, last: Int, orderBy: FacilityMetadataOrderByInput, skip: Int, where: FacilityMetadataWhereInput): [FacilityMetadata!]!
  facilityMetadatasConnection(after: String, before: String, first: Int, last: Int, orderBy: FacilityMetadataOrderByInput, skip: Int, where: FacilityMetadataWhereInput): FacilityMetadataConnection!
  geometries(after: String, before: String, first: Int, last: Int, orderBy: GeometryOrderByInput, skip: Int, where: GeometryWhereInput): [Geometry!]!
  geometriesConnection(after: String, before: String, first: Int, last: Int, orderBy: GeometryOrderByInput, skip: Int, where: GeometryWhereInput): GeometryConnection!
  geometry(where: GeometryWhereUniqueInput!): Geometry
  governmentActor(where: GovernmentActorWhereUniqueInput!): GovernmentActor
  governmentActorProfile(where: GovernmentActorProfileWhereUniqueInput!): GovernmentActorProfile
  governmentActorProfiles(after: String, before: String, first: Int, last: Int, orderBy: GovernmentActorProfileOrderByInput, skip: Int, where: GovernmentActorProfileWhereInput): [GovernmentActorProfile!]!
  governmentActorProfilesConnection(after: String, before: String, first: Int, last: Int, orderBy: GovernmentActorProfileOrderByInput, skip: Int, where: GovernmentActorProfileWhereInput): GovernmentActorProfileConnection!
  governmentActors(after: String, before: String, first: Int, last: Int, orderBy: GovernmentActorOrderByInput, skip: Int, where: GovernmentActorWhereInput): [GovernmentActor!]!
  governmentActorsConnection(after: String, before: String, first: Int, last: Int, orderBy: GovernmentActorOrderByInput, skip: Int, where: GovernmentActorWhereInput): GovernmentActorConnection!
  governmentBodies(after: String, before: String, first: Int, last: Int, orderBy: GovernmentBodyOrderByInput, skip: Int, where: GovernmentBodyWhereInput): [GovernmentBody!]!
  governmentBodiesConnection(after: String, before: String, first: Int, last: Int, orderBy: GovernmentBodyOrderByInput, skip: Int, where: GovernmentBodyWhereInput): GovernmentBodyConnection!
  governmentBody(where: GovernmentBodyWhereUniqueInput!): GovernmentBody
  governmentBodyMetadata(where: GovernmentBodyMetadataWhereUniqueInput!): GovernmentBodyMetadata
  governmentBodyMetadatas(after: String, before: String, first: Int, last: Int, orderBy: GovernmentBodyMetadataOrderByInput, skip: Int, where: GovernmentBodyMetadataWhereInput): [GovernmentBodyMetadata!]!
  governmentBodyMetadatasConnection(after: String, before: String, first: Int, last: Int, orderBy: GovernmentBodyMetadataOrderByInput, skip: Int, where: GovernmentBodyMetadataWhereInput): GovernmentBodyMetadataConnection!
  governmentFacilities(after: String, before: String, first: Int, last: Int, orderBy: GovernmentFacilityOrderByInput, skip: Int, where: GovernmentFacilityWhereInput): [GovernmentFacility!]!
  governmentFacilitiesConnection(after: String, before: String, first: Int, last: Int, orderBy: GovernmentFacilityOrderByInput, skip: Int, where: GovernmentFacilityWhereInput): GovernmentFacilityConnection!
  governmentFacility(where: GovernmentFacilityWhereUniqueInput!): GovernmentFacility
  location(where: LocationWhereUniqueInput!): Location
  locationMetadata(where: LocationMetadataWhereUniqueInput!): LocationMetadata
  locationMetadatas(after: String, before: String, first: Int, last: Int, orderBy: LocationMetadataOrderByInput, skip: Int, where: LocationMetadataWhereInput): [LocationMetadata!]!
  locationMetadatasConnection(after: String, before: String, first: Int, last: Int, orderBy: LocationMetadataOrderByInput, skip: Int, where: LocationMetadataWhereInput): LocationMetadataConnection!
  locations(after: String, before: String, first: Int, last: Int, orderBy: LocationOrderByInput, skip: Int, where: LocationWhereInput): [Location!]!
  locationsConnection(after: String, before: String, first: Int, last: Int, orderBy: LocationOrderByInput, skip: Int, where: LocationWhereInput): LocationConnection!
  phoneNumber(where: PhoneNumberWhereUniqueInput!): PhoneNumber
  phoneNumbers(after: String, before: String, first: Int, last: Int, orderBy: PhoneNumberOrderByInput, skip: Int, where: PhoneNumberWhereInput): [PhoneNumber!]!
  phoneNumbersConnection(after: String, before: String, first: Int, last: Int, orderBy: PhoneNumberOrderByInput, skip: Int, where: PhoneNumberWhereInput): PhoneNumberConnection!
  user(where: UserWhereUniqueInput!): User
  userProfile(where: UserProfileWhereUniqueInput!): UserProfile
  userProfiles(after: String, before: String, first: Int, last: Int, orderBy: UserProfileOrderByInput, skip: Int, where: UserProfileWhereInput): [UserProfile!]!
  userProfilesConnection(after: String, before: String, first: Int, last: Int, orderBy: UserProfileOrderByInput, skip: Int, where: UserProfileWhereInput): UserProfileConnection!
  users(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
  usersConnection(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): UserConnection!
}

type User {
  cognitoId: String!
  createdAt: DateTime!
  handle: String
  id: ID!
  profile: UserProfile!
  updatedAt: DateTime!
}

type UserConnection {
  aggregate: AggregateUser!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

input UserCreateInput {
  cognitoId: String!
  handle: String
  id: ID
  profile: UserProfileCreateOneWithoutUserInput!
}

input UserCreateOneWithoutProfileInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutProfileInput
}

input UserCreateWithoutProfileInput {
  cognitoId: String!
  handle: String
  id: ID
}

type UserEdge {
  cursor: String!
  node: User!
}

enum UserOrderByInput {
  cognitoId_ASC
  cognitoId_DESC
  createdAt_ASC
  createdAt_DESC
  handle_ASC
  handle_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserProfile {
  avatar: String
  createdAt: DateTime!
  email(after: String, before: String, first: Int, last: Int, orderBy: EmailAddressOrderByInput, skip: Int, where: EmailAddressWhereInput): [EmailAddress!]
  firstName: String
  id: ID!
  lastName: String
  location: String
  phone_number(after: String, before: String, first: Int, last: Int, orderBy: PhoneNumberOrderByInput, skip: Int, where: PhoneNumberWhereInput): [PhoneNumber!]
  updatedAt: DateTime!
  user: User!
}

type UserProfileConnection {
  aggregate: AggregateUserProfile!
  edges: [UserProfileEdge!]!
  pageInfo: PageInfo!
}

input UserProfileCreateInput {
  avatar: String
  email: EmailAddressCreateManyInput
  firstName: String
  id: ID
  lastName: String
  location: String
  phone_number: PhoneNumberCreateManyInput
  user: UserCreateOneWithoutProfileInput!
}

input UserProfileCreateOneWithoutUserInput {
  connect: UserProfileWhereUniqueInput
  create: UserProfileCreateWithoutUserInput
}

input UserProfileCreateWithoutUserInput {
  avatar: String
  email: EmailAddressCreateManyInput
  firstName: String
  id: ID
  lastName: String
  location: String
  phone_number: PhoneNumberCreateManyInput
}

type UserProfileEdge {
  cursor: String!
  node: UserProfile!
}

enum UserProfileOrderByInput {
  avatar_ASC
  avatar_DESC
  createdAt_ASC
  createdAt_DESC
  firstName_ASC
  firstName_DESC
  id_ASC
  id_DESC
  lastName_ASC
  lastName_DESC
  location_ASC
  location_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input UserProfileUpdateInput {
  avatar: String
  email: EmailAddressUpdateManyInput
  firstName: String
  lastName: String
  location: String
  phone_number: PhoneNumberUpdateManyInput
  user: UserUpdateOneRequiredWithoutProfileInput
}

input UserProfileUpdateManyMutationInput {
  avatar: String
  firstName: String
  lastName: String
  location: String
}

input UserProfileUpdateOneRequiredWithoutUserInput {
  connect: UserProfileWhereUniqueInput
  create: UserProfileCreateWithoutUserInput
  update: UserProfileUpdateWithoutUserDataInput
  upsert: UserProfileUpsertWithoutUserInput
}

input UserProfileUpdateWithoutUserDataInput {
  avatar: String
  email: EmailAddressUpdateManyInput
  firstName: String
  lastName: String
  location: String
  phone_number: PhoneNumberUpdateManyInput
}

input UserProfileUpsertWithoutUserInput {
  create: UserProfileCreateWithoutUserInput!
  update: UserProfileUpdateWithoutUserDataInput!
}

input UserProfileWhereInput {
  AND: [UserProfileWhereInput!]
  avatar: String
  avatar_contains: String
  avatar_ends_with: String
  avatar_gt: String
  avatar_gte: String
  avatar_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_not: String
  avatar_not_contains: String
  avatar_not_ends_with: String
  avatar_not_in: [String!]
  avatar_not_starts_with: String
  avatar_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email_every: EmailAddressWhereInput
  email_none: EmailAddressWhereInput
  email_some: EmailAddressWhereInput
  firstName: String
  firstName_contains: String
  firstName_ends_with: String
  firstName_gt: String
  firstName_gte: String
  firstName_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_not: String
  firstName_not_contains: String
  firstName_not_ends_with: String
  firstName_not_in: [String!]
  firstName_not_starts_with: String
  firstName_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  lastName: String
  lastName_contains: String
  lastName_ends_with: String
  lastName_gt: String
  lastName_gte: String
  lastName_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_not: String
  lastName_not_contains: String
  lastName_not_ends_with: String
  lastName_not_in: [String!]
  lastName_not_starts_with: String
  lastName_starts_with: String
  location: String
  location_contains: String
  location_ends_with: String
  location_gt: String
  location_gte: String
  location_in: [String!]
  location_lt: String
  location_lte: String
  location_not: String
  location_not_contains: String
  location_not_ends_with: String
  location_not_in: [String!]
  location_not_starts_with: String
  location_starts_with: String
  NOT: [UserProfileWhereInput!]
  OR: [UserProfileWhereInput!]
  phone_number_every: PhoneNumberWhereInput
  phone_number_none: PhoneNumberWhereInput
  phone_number_some: PhoneNumberWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
  user: UserWhereInput
}

input UserProfileWhereUniqueInput {
  id: ID
}

input UserUpdateInput {
  cognitoId: String
  handle: String
  profile: UserProfileUpdateOneRequiredWithoutUserInput
}

input UserUpdateManyMutationInput {
  cognitoId: String
  handle: String
}

input UserUpdateOneRequiredWithoutProfileInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutProfileInput
  update: UserUpdateWithoutProfileDataInput
  upsert: UserUpsertWithoutProfileInput
}

input UserUpdateWithoutProfileDataInput {
  cognitoId: String
  handle: String
}

input UserUpsertWithoutProfileInput {
  create: UserCreateWithoutProfileInput!
  update: UserUpdateWithoutProfileDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  cognitoId: String
  cognitoId_contains: String
  cognitoId_ends_with: String
  cognitoId_gt: String
  cognitoId_gte: String
  cognitoId_in: [String!]
  cognitoId_lt: String
  cognitoId_lte: String
  cognitoId_not: String
  cognitoId_not_contains: String
  cognitoId_not_ends_with: String
  cognitoId_not_in: [String!]
  cognitoId_not_starts_with: String
  cognitoId_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  handle: String
  handle_contains: String
  handle_ends_with: String
  handle_gt: String
  handle_gte: String
  handle_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_not: String
  handle_not_contains: String
  handle_not_ends_with: String
  handle_not_in: [String!]
  handle_not_starts_with: String
  handle_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  profile: UserProfileWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input UserWhereUniqueInput {
  cognitoId: String
  handle: String
  id: ID
}
